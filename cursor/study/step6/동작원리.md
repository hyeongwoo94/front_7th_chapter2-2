# 단계 6: React 동작 원리 명세서

## 📋 개요

단계 6은 **React의 기본 Hook 시스템**을 설명합니다. React가 어떻게 `useState`와 `useEffect`를 구현하고, 훅 상태를 관리하며, 사이드 이펙트를 처리하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. useState - 상태 관리 훅

**원리**: `useState`는 컴포넌트의 상태를 관리하는 훅입니다. 경로와 커서를 사용하여 각 컴포넌트의 상태를 격리하고 저장합니다.

**동작 흐름**:
```
첫 렌더링:
  useState(0)
    → 경로와 커서로 상태 조회
    → 상태 없음 → 초기값(0) 설정
    → 상태 저장
    → 커서 증가
    → [상태, setter] 반환

재렌더링:
  useState(0)
    → 경로와 커서로 상태 조회
    → 기존 상태 있음 → 기존 상태 사용
    → 커서 증가
    → [상태, setter] 반환

setState 호출:
  setState(1)
    → 현재 상태 조회
    → 새 값 계산 (함수형 업데이트 지원)
    → Object.is로 비교
    → 값이 다르면 상태 업데이트
    → enqueueRender() 호출 (재렌더링 스케줄링)
```

**핵심 개념**:
- 경로와 커서로 상태 격리
- 첫 렌더링 시 초기값 설정
- 재렌더링 시 기존 상태 사용
- 함수형 초기값 및 업데이트 지원
- Object.is로 값 비교 (같으면 재렌더링 안 함)

**특징**:
- **함수형 초기값**: `useState(() => expensive())` - 첫 렌더링에만 실행
- **함수형 업데이트**: `setState(prev => prev + 1)` - 이전 값 기반 업데이트
- **값 비교**: `Object.is()`로 비교하여 불필요한 재렌더링 방지

---

### 2. useEffect - 사이드 이펙트 훅

**원리**: `useEffect`는 사이드 이펙트를 처리하는 훅입니다. 의존성 배열을 비교하여 필요할 때만 실행합니다.

**동작 흐름**:
```
첫 렌더링:
  useEffect(effect, [a, b])
    → 이전 훅 없음 → shouldRun = true
    → 이펙트 큐에 추가
    → 커서 증가

재렌더링 (의존성 변경 안 됨):
  useEffect(effect, [a, b])
    → 이전 의존성 [a, b]와 비교
    → shallowEquals([a, b], [a, b]) = true
    → shouldRun = false
    → 실행 안 함

재렌더링 (의존성 변경됨):
  useEffect(effect, [a, c])
    → 이전 의존성 [a, b]와 비교
    → shallowEquals([a, b], [a, c]) = false
    → shouldRun = true
    → 이전 클린업 실행
    → 이펙트 큐에 추가

이펙트 실행 (렌더링 후):
  flushEffects()
    → 큐에서 이펙트 꺼내기
    → 비동기로 실행
    → 클린업 함수 저장
```

**핵심 개념**:
- 의존성 배열 비교 (`shallowEquals`)
- 첫 렌더링 또는 의존성 변경 시 실행
- 이전 클린업 함수 먼저 실행
- 렌더링 후 비동기 실행

**의존성 처리**:
- **deps 없음**: 매 렌더링마다 실행
- **deps 빈 배열**: 첫 렌더링에만 실행
- **deps 있음**: 의존성이 변경될 때만 실행

---

### 3. 훅 상태 저장 구조

**원리**: 훅 상태는 경로를 키로 하는 Map에 저장되며, 각 경로마다 훅 상태 배열을 가집니다.

**저장 구조**:
```typescript
context.hooks.state = Map<
  "0",              // 경로
  [                 // 훅 상태 배열
    state1,         // 첫 번째 useState (cursor=0)
    state2,         // 두 번째 useState (cursor=1)
    {               // useEffect (cursor=2)
      kind: 'effect',
      deps: [...],
      cleanup: null,
      effect: fn
    },
    ...
  ]
>
```

**커서 동작**:
- **초기값**: 0 (enterComponent에서 설정)
- **증가**: 각 훅 호출마다 `incrementCursor`
- **순서 추적**: 커서로 훅 호출 순서 추적

**핵심 개념**:
- 경로별로 상태 격리
- 배열 인덱스(커서)로 훅 순서 추적
- 같은 순서로 호출되어야 함

---

### 4. 미사용 훅 정리 (Cleanup)

**원리**: 렌더링 후 방문하지 않은 컴포넌트의 훅을 정리합니다. useEffect의 클린업 함수를 실행하고 상태를 제거합니다.

**정리 과정**:
```
cleanupUnusedHooks()
  → 모든 경로 순회
  → visited에 없는 경로 찾기
  → useEffect 클린업 실행
  → 상태 및 커서 제거
```

**핵심 개념**:
- `visited` Set에 없는 경로는 미사용
- useEffect 클린업 함수 실행
- 메모리 누수 방지

**언제 발생?**
- 컴포넌트가 언마운트될 때
- 조건부 렌더링으로 컴포넌트가 사라질 때
- 리스트에서 항목이 제거될 때

---

### 5. 이펙트 실행 메커니즘

**원리**: 예약된 이펙트는 렌더링 후 비동기로 실행됩니다. 클린업 함수는 다음 이펙트 실행 전에 호출됩니다.

**실행 순서**:
```
렌더링 완료
  ↓
flushEffects()
  ↓
각 이펙트를 비동기로 실행
  ├─ 이펙트 함수 실행
  ├─ 클린업 함수 저장
  └─ 큐 초기화
```

**핵심 개념**:
- 렌더링 후 비동기 실행
- 클린업 함수는 다음 이펙트 실행 전에 호출
- 큐에 추가된 순서대로 실행

**왜 비동기인가?**
- 렌더링 중에는 DOM이 안정적이지 않을 수 있음
- 비동기 실행으로 렌더링 완료 후 안전하게 실행
- 여러 이펙트를 순차적으로 실행

---

## 🔄 React 전체 시스템에서의 위치

단계 6은 React의 **Hook 시스템**을 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리] (기반)
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation]
         ↓
[단계 6: Hook 시스템] ← 현재 단계
         ↓
[단계 7: 확장 Hook & HOC] (단계 6 기반)
```

**역할**:
- 기본 Hook 구현 (useState, useEffect)
- 훅 상태 관리
- 사이드 이펙트 처리
- 이후 확장 Hook(단계 7)의 기반

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **상태 저장**: React는 Fiber 노드에 훅 상태를 저장
2. **커서 추적**: React는 내부적으로 훅 인덱스를 추적
3. **의존성 비교**: React는 얕은 비교로 의존성 확인
4. **이펙트 실행**: React는 렌더링 후 이펙트 실행

---

## 📚 관련 개념

- **useState**: 상태 관리 훅
- **useEffect**: 사이드 이펙트 훅
- **Hook Rules**: 훅 규칙
- **Dependency Array**: 의존성 배열
- **Cleanup Function**: 클린업 함수
- **Effect Queue**: 이펙트 큐

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. useState가 어떻게 상태를 관리하는지
2. useEffect가 어떻게 사이드 이펙트를 처리하는지
3. 훅 상태가 어떻게 저장되고 관리되는지
4. 미사용 훅이 어떻게 정리되는지

---

## ⚠️ 중요한 규칙

1. **훅은 컴포넌트 내부에서만 호출**: `currentPath`가 null이면 에러
2. **훅 호출 순서 유지**: 조건문/반복문 안에서 훅 호출 금지
3. **경로 기반 격리**: 경로가 다르면 완전히 별개의 상태
4. **의존성 배열**: useEffect의 의존성 배열은 정확히 명시

---

## 💡 Hook 규칙의 이유

1. **컴포넌트 내부에서만**: 경로와 커서가 필요함
2. **순서 유지**: 커서로 상태를 찾기 때문
3. **조건문 금지**: 순서가 달라지면 잘못된 상태 참조

---

이 명세서는 React의 기본 Hook 시스템을 설명하며, 함수형 컴포넌트에서 상태와 사이드 이펙트를 관리하는 핵심 원리를 이해하는 기반이 됩니다.

