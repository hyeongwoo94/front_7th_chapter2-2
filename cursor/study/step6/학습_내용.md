# 단계 6: 기본 Hook 시스템 - 학습 내용

이 문서는 단계 6에서 학습해야 할 핵심 개념과 구현 내용을 설명합니다.

## 📚 핵심 개념

### 1. useState

`useState`는 컴포넌트의 상태를 관리하는 훅입니다.

**동작 원리**:
1. 경로와 커서로 상태 조회
2. 첫 렌더링 시 초기값 설정
3. 재렌더링 시 기존 상태 사용
4. setter 호출 시 상태 변경 및 재렌더링 스케줄링

**특징**:
- 함수형 초기값 지원: `useState(() => expensive())`
- 함수형 업데이트 지원: `setState(prev => prev + 1)`
- Object.is로 값 비교: 값이 같으면 재렌더링 안 함

### 2. useEffect

`useEffect`는 사이드 이펙트를 처리하는 훅입니다.

**동작 원리**:
1. 의존성 배열 비교
2. 변경되었거나 첫 렌더링이면 이펙트 실행 예약
3. 이전 클린업 함수 실행
4. 렌더링 후 비동기로 이펙트 실행

**특징**:
- 의존성 배열 비교: `shallowEquals`로 비교
- 클린업 함수: 이펙트 실행 전 이전 클린업 실행
- 비동기 실행: 렌더링 후 실행

### 3. 훅 상태 저장 구조

```typescript
context.hooks.state = Map<
  "0",           // 경로
  [              // 훅 상태 배열
    state1,      // 첫 번째 useState
    state2,      // 두 번째 useState
    { kind: 'effect', deps: [...], cleanup: null, effect: fn }  // useEffect
  ]
>
```

### 4. 커서 동작

- **초기값**: 0 (enterComponent에서 설정)
- **증가**: 각 훅 호출마다 `incrementCursor`
- **순서 추적**: 커서로 훅 호출 순서 추적

---

## 🔧 구현 함수 상세

### 1. `useState<T>(initialValue)`

**목적**: 컴포넌트의 상태를 관리합니다.

**처리 순서**:
1. 현재 경로 및 커서 가져오기
2. 상태 조회 (첫 렌더링 시 초기값 설정)
3. setter 함수 생성
4. 커서 증가 및 반환

**구현**:
```typescript
export const useState = <T>(initialValue: T | (() => T)): [T, (nextValue: T | ((prev: T) => T)) => void] => {
  // 1. 현재 컴포넌트의 훅 커서와 상태 배열을 가져옵니다.
  const path = context.hooks.currentPath;
  const cursor = context.hooks.currentCursor;
  const hooks = context.hooks.currentHooks;

  // 2. 첫 렌더링이라면 초기값으로 상태를 설정합니다.
  if (!hooks[cursor]) {
    const value = typeof initialValue === "function" ? (initialValue as () => T)() : initialValue;
    hooks[cursor] = value;
    context.hooks.state.set(path, hooks);
  }

  const state = hooks[cursor] as T;

  // 3. 상태 변경 함수(setter)를 생성합니다.
  const setState = (nextValue: T | ((prev: T) => T)) => {
    const currentHooks = context.hooks.state.get(path) || [];
    const currentState = currentHooks[cursor] as T;

    let newValue: T;
    if (typeof nextValue === "function") {
      newValue = (nextValue as (prev: T) => T)(currentState);
    } else {
      newValue = nextValue;
    }

    // 새 값이 이전 값과 같으면(Object.is) 재렌더링을 건너뜁니다.
    if (Object.is(currentState, newValue)) {
      return;
    }

    // 값이 다르면 상태를 업데이트하고 재렌더링을 예약합니다.
    currentHooks[cursor] = newValue;
    context.hooks.state.set(path, currentHooks);
    enqueueRender();
  };

  // 4. 훅 커서를 증가시키고 [상태, setter]를 반환합니다.
  incrementCursor(path);
  return [state, setState];
};
```

**요점**:
- 경로 기반 격리: 각 컴포넌트의 상태는 경로로 완전히 격리
- 커서로 순서 추적: 훅 호출 순서를 커서로 추적
- 함수형 초기값: `initialValue`가 함수면 첫 렌더링에만 호출
- 함수형 업데이트: setter에 함수 전달 가능
- Object.is 비교: 값 변경 여부 확인
- 재렌더링 스케줄링: `enqueueRender()` 호출

---

### 2. `useEffect(effect, deps?)`

**목적**: 사이드 이펙트를 처리합니다.

**처리 순서**:
1. 현재 경로 및 커서 가져오기
2. 이전 이펙트 훅 조회
3. 의존성 비교
4. 이전 클린업 실행
5. 새 이펙트 스케줄링
6. 훅 정보 저장
7. 커서 증가

**구현**:
```typescript
export const useEffect = (effect: () => (() => void) | void, deps?: unknown[]): void => {
  // 1. 이전 훅의 의존성 배열과 현재 의존성 배열을 비교합니다.
  const path = context.hooks.currentPath;
  const cursor = context.hooks.currentCursor;
  const hooks = context.hooks.currentHooks;

  const prevHook = hooks[cursor] as EffectHook | undefined;
  const prevDeps = prevHook?.deps || null;

  // 2. 의존성이 변경되었거나 첫 렌더링일 경우, 이펙트 실행을 예약합니다.
  let shouldRun = false;

  if (!prevHook) {
    // 첫 렌더링
    shouldRun = true;
  } else if (deps === undefined) {
    // deps가 없으면 매 렌더링마다 실행
    shouldRun = true;
  } else if (prevDeps === null || !shallowEquals(prevDeps, deps)) {
    // 의존성이 변경됨
    shouldRun = true;
  }

  // 3. 이펙트 실행 전, 이전 클린업 함수가 있다면 먼저 실행합니다.
  if (shouldRun && prevHook?.cleanup) {
    prevHook.cleanup();
  }

  // 4. 예약된 이펙트는 렌더링이 끝난 후 비동기로 실행됩니다.
  const effectHook: EffectHook = {
    kind: HookTypes.EFFECT,
    deps: deps === undefined ? null : deps,
    cleanup: null,
    effect,
  };

  hooks[cursor] = effectHook;
  context.hooks.state.set(path, hooks);

  if (shouldRun) {
    context.effects.queue.push({ path, cursor });
  }

  incrementCursor(path);
};
```

**요점**:
- 의존성 비교: `shallowEquals`로 의존성 배열 비교
- 첫 렌더링: 이전 훅이 없으면 실행
- deps 없음: deps가 없으면 매 렌더링마다 실행
- 클린업 실행: 이전 클린업 함수를 먼저 실행
- 이펙트 큐: 실행할 이펙트를 큐에 추가
- 비동기 실행: 렌더링 후 비동기로 실행

---

### 3. `cleanupUnusedHooks()`

**목적**: 사용되지 않은 훅을 정리합니다.

**처리 순서**:
1. 방문하지 않은 경로 찾기
2. useEffect 클린업 실행
3. 상태 및 커서 제거

**구현**:
```typescript
export const cleanupUnusedHooks = () => {
  // 방문하지 않은 경로 찾기
  for (const path of context.hooks.state.keys()) {
    if (!context.hooks.visited.has(path)) {
      const hooks = context.hooks.state.get(path) || [];

      // useEffect 클린업 실행
      for (const hook of hooks) {
        if (hook && (hook as EffectHook).kind === HookTypes.EFFECT) {
          const effectHook = hook as EffectHook;
          if (effectHook.cleanup) {
            effectHook.cleanup();
          }
        }
      }

      // 상태 및 커서 제거
      context.hooks.state.delete(path);
      context.hooks.cursor.delete(path);
    }
  }
};
```

**요점**:
- visited 확인: `visited` Set에 없는 경로는 미사용
- 클린업 실행: useEffect의 클린업 함수 실행
- 상태 정리: 미사용 경로의 상태 및 커서 제거

---

### 4. `flushEffects()`

**목적**: 예약된 이펙트를 실행합니다.

**처리 순서**:
1. 이펙트 큐 확인
2. 각 이펙트를 비동기로 실행
3. 클린업 함수 저장
4. 큐 초기화

**구현**:
```typescript
export const flushEffects = (): void => {
  const queue = context.effects.queue;

  for (const { path, cursor } of queue) {
    enqueue(() => {
      const hooks = context.hooks.state.get(path) || [];
      const hook = hooks[cursor] as EffectHook | undefined;

      if (hook && hook.kind === HookTypes.EFFECT) {
        const cleanup = hook.effect();
        if (cleanup) {
          hook.cleanup = cleanup;
        }
      }
    });
  }

  queue.length = 0;
};
```

**요점**:
- 비동기 실행: `enqueue`로 비동기 실행
- 클린업 저장: 이펙트 실행 결과가 함수면 클린업으로 저장
- 큐 초기화: 실행 후 큐 비우기

---

## 💡 핵심 원칙

### 1. 훅 규칙

1. **컴포넌트 내부에서만 호출**: `currentPath`가 null이면 에러
2. **호출 순서 유지**: 조건문/반복문 안에서 훅 호출 금지
3. **경로 기반 격리**: 각 컴포넌트의 훅 상태는 경로로 완전히 격리

### 2. 상태 저장 구조

```typescript
context.hooks.state = Map<
  "0",           // 경로
  [              // 훅 상태 배열
    state1,      // 첫 번째 useState
    state2,      // 두 번째 useState
    { kind: 'effect', deps: [...], cleanup: null, effect: fn }  // useEffect
  ]
>
```

### 3. 커서 동작

- **초기값**: 0 (enterComponent에서 설정)
- **증가**: 각 훅 호출마다 `incrementCursor`
- **순서 추적**: 커서로 훅 호출 순서 추적

### 4. useEffect 동작

| 조건 | 실행 여부 |
|------|----------|
| 첫 렌더링 | ✅ 실행 |
| deps 없음 | ✅ 매 렌더링마다 실행 |
| deps 변경됨 | ✅ 실행 |
| deps 변경 안 됨 | ❌ 실행 안 함 |

---

## 🎯 실습 예시

### 예시 1: useState 동작

```typescript
// 첫 렌더링
const [count, setCount] = useState(0);
  → cursor=0, hooks[0] = 0 (초기값 설정)
  → incrementCursor() → cursor=1

// 두 번째 렌더링 (재렌더링)
const [count, setCount] = useState(0);
  → cursor=0, hooks[0] = 0 (기존 값 사용)
  → incrementCursor() → cursor=1

// setState 호출
setCount(1);
  → Object.is(0, 1) = false
  → hooks[0] = 1
  → enqueueRender() (재렌더링 스케줄링)
```

### 예시 2: useEffect 동작

```typescript
// 첫 렌더링
useEffect(() => {
  console.log('mounted');
  return () => console.log('unmounted');
}, []);
  → shouldRun = true (첫 렌더링)
  → 큐에 추가
  → flushEffects()에서 실행

// 두 번째 렌더링
useEffect(() => {
  console.log('mounted');
  return () => console.log('unmounted');
}, []);
  → shallowEquals([], []) = true
  → shouldRun = false
  → 실행 안 함
```

### 예시 3: 클린업 처리

```typescript
// 컴포넌트 언마운트
cleanupUnusedHooks()
  → visited에 없는 경로 찾기
  → useEffect 클린업 실행
  → 상태 및 커서 제거
```

---

## ⚠️ 주의사항

1. **커서 증가 누락**: incrementCursor 호출 안 하면 다음 훅에서 잘못된 위치 참조 ❌
2. **경로 격리 누락**: 경로가 다르면 완전히 별개의 상태여야 함 ❌
3. **클린업 실행 시점**: useEffect에서 클린업 실행하면 안 됨 (flushEffects에서) ❌
4. **의존성 비교**: shallowEquals 사용, deepEquals 아님 ❌
5. **이펙트 큐 초기화**: flushEffects에서 큐 초기화 누락 ❌

---

## 💡 자주 하는 실수

### 1. 커서 증가 누락

```typescript
// ❌ 잘못된 예
export const useState = <T>(initialValue: T) => {
  const state = hooks[cursor];
  return [state, setState];
  // incrementCursor() 호출 안 함!
};

// ✅ 올바른 예
export const useState = <T>(initialValue: T) => {
  const state = hooks[cursor];
  incrementCursor(path);  // 커서 증가
  return [state, setState];
};
```

### 2. 클린업 실행 시점

```typescript
// ❌ 잘못된 예
export const useEffect = (effect, deps) => {
  if (shouldRun) {
    const cleanup = effect();  // useEffect에서 직접 실행!
    if (cleanup) {
      hook.cleanup = cleanup;
    }
  }
};

// ✅ 올바른 예
export const useEffect = (effect, deps) => {
  if (shouldRun) {
    context.effects.queue.push({ path, cursor });  // 큐에 추가
  }
  // flushEffects()에서 실행
};
```

### 3. 의존성 비교 실수

```typescript
// ❌ 잘못된 예
if (!deepEquals(prevDeps, deps)) {  // deepEquals 사용!
  shouldRun = true;
}

// ✅ 올바른 예
if (!shallowEquals(prevDeps, deps)) {  // shallowEquals 사용
  shouldRun = true;
}
```

---

## 🔄 다음 단계

이제 기본 Hook 시스템이 완료되었습니다. 다음 단계에서는 확장 Hook & HOC를 구현합니다.

**다음 단계**: [단계 7 - 확장 Hook & HOC](../step7/학습_내용.md)

