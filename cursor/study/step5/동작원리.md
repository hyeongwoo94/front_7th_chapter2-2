# 단계 5: React 동작 원리 명세서

## 📋 개요

단계 5는 **React의 Reconciliation(재조정) 알고리즘**을 설명합니다. React가 어떻게 이전 Virtual DOM과 새로운 Virtual DOM을 비교하여 최소한의 DOM 변경만 수행하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. Reconciliation (재조정) 알고리즘

**원리**: React는 이전 Virtual DOM과 새로운 Virtual DOM을 비교하여 최소한의 DOM 변경만 수행합니다. 타입과 키를 비교하여 마운트, 업데이트, 언마운트를 결정합니다.

**전략**:

| 조건 | 동작 | 설명 |
|------|------|------|
| 타입/키 다름 | 언마운트 후 마운트 | 기존 DOM 제거 후 새로 생성 |
| 타입/키 같음 | 업데이트 | 기존 DOM 재사용, 속성만 변경 |

**핵심 개념**:
- 타입과 키가 같으면 DOM을 재사용
- 타입이나 키가 다르면 완전 교체
- 최소한의 DOM 변경으로 성능 최적화

**왜 중요한가?**
- DOM 조작은 비용이 큼
- 최소한의 변경만 수행하여 성능 향상
- 사용자 경험 개선 (깜빡임 최소화)

---

### 2. 마운트 vs 업데이트

**마운트 (Mount)**:
- 새로운 노드를 DOM에 추가
- 첫 렌더링 또는 타입/키 변경 시 발생
- DOM 요소를 새로 생성

**업데이트 (Update)**:
- 기존 DOM을 재사용하고 속성만 변경
- 타입/키가 같을 때 발생
- 최소한의 변경만 수행

**비교 로직**:
```typescript
// 타입/키 비교
if (instance.node.type !== node.type || instance.key !== node.key) {
  // 다름 → 언마운트 후 마운트
  removeInstance(parentDom, instance);
  return mount(parentDom, node, path);
} else {
  // 같음 → 업데이트
  return update(instance, node, parentDom, path);
}
```

**핵심 개념**:
- 타입과 키로 재사용 여부 결정
- 재사용 가능하면 업데이트, 불가능하면 교체
- DOM 재사용이 성능 최적화의 핵심

---

### 3. 자식 노드 매칭 전략

**원리**: 자식 노드들을 효율적으로 매칭하기 위해 Key 기반 매칭과 인덱스 기반 매칭을 사용합니다.

**매칭 우선순위**:
1. **Key로 매칭** (key가 있고 타입이 같음)
   - 가장 효율적
   - 위치 변경 감지 가능
   - DOM 재사용 최대화

2. **인덱스로 매칭** (key가 없고 타입이 같음)
   - 단순 매칭
   - 순서 변경 처리
   - 제한적 최적화

3. **새로 마운트** (매칭되지 않음)
   - 완전히 새로운 노드
   - DOM 새로 생성

**구현 예시**:
```typescript
// Key 기반 Map 생성
const keyMap = new Map<string | number, Instance>();
for (const oldChild of oldChildren) {
  if (oldChild && oldChild.key !== null) {
    keyMap.set(oldChild.key, oldChild);
  }
}

// Key로 매칭 시도
if (newChild.key !== null && keyMap.has(newChild.key)) {
  const matched = keyMap.get(newChild.key)!;
  if (matched.node.type === newChild.type) {
    // 재사용 가능
    childInstance = reconcile(parentDom, matched, newChild, childPath);
  }
}
```

**핵심 개념**:
- Key가 있으면 Key로 우선 매칭
- Key가 없으면 인덱스로 매칭
- 타입이 같아야 재사용 가능

**성능 영향**:
- Key 사용 시 DOM 재사용 최대화
- Key 없이 순서 변경 시 불필요한 재생성 발생
- Key는 리스트 렌더링에서 필수

---

### 4. 컴포넌트 경로 관리

**원리**: 컴포넌트의 경로는 마운트 시 생성되고, 업데이트 시 재사용됩니다. 이는 훅 상태를 유지하기 위해 중요합니다.

**마운트 시**:
```typescript
const componentPath = createChildPath(path, node.key, 0, node.type);
// 새 경로 생성
```

**업데이트 시**:
```typescript
const path = oldInstance.path;  // 기존 경로 재사용!
// 훅 상태 유지를 위해 같은 경로 사용
```

**핵심 개념**:
- 마운트: 새 경로 생성
- 업데이트: 기존 경로 재사용 (훅 상태 유지)
- 경로가 바뀌면 훅 상태 손실

**왜 중요한가?**
- 경로가 바뀌면 훅 상태가 초기화됨
- 같은 컴포넌트는 같은 경로를 유지해야 함
- 이는 React Hooks가 동작하는 기반

---

### 5. 재귀적 Reconciliation

**원리**: Reconciliation은 재귀적으로 수행됩니다. 각 노드에서 자식 노드들도 재귀적으로 비교합니다.

**재귀 구조**:
```
reconcile(루트)
  ├─ reconcile(자식1)
  │   ├─ reconcile(손자1)
  │   └─ reconcile(손자2)
  ├─ reconcile(자식2)
  └─ reconcile(자식3)
```

**핵심 개념**:
- 트리 구조를 재귀적으로 탐색
- 각 노드에서 타입/키 비교
- 변경된 부분만 업데이트

**성능 최적화**:
- 변경되지 않은 부분은 건너뜀
- 깊이 우선 탐색으로 효율적 처리
- 최소한의 비교만 수행

---

## 🔄 React 전체 시스템에서의 위치

단계 5는 React의 **핵심 렌더링 알고리즘**을 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리]
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation] ← 현재 단계 (핵심!)
         ↓
[단계 6: Hook 시스템]
```

**역할**:
- Virtual DOM 비교 및 DOM 업데이트
- 최소한의 DOM 변경으로 성능 최적화
- React의 핵심 렌더링 알고리즘
- 이후 모든 렌더링의 기반

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **Fiber 알고리즘**: React는 Fiber 노드를 사용하여 Reconciliation 수행
2. **Diffing 알고리즘**: 타입과 키를 비교하여 변경 감지
3. **Key 기반 최적화**: Key를 사용하여 DOM 재사용 최대화
4. **재귀적 처리**: 트리 구조를 재귀적으로 탐색

---

## 📚 관련 개념

- **Reconciliation**: 재조정 알고리즘
- **Diffing Algorithm**: 차이점 계산 알고리즘
- **Mount**: 마운트 (DOM 추가)
- **Update**: 업데이트 (DOM 수정)
- **Unmount**: 언마운트 (DOM 제거)
- **Key**: 리스트 렌더링용 키
- **Fiber**: React의 내부 노드 구조

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. React가 어떻게 Virtual DOM을 비교하는지
2. 마운트와 업데이트가 어떻게 구분되는지
3. Key가 왜 중요한지
4. Reconciliation이 어떻게 성능을 최적화하는지

---

## ⚠️ 중요한 주의사항

1. **경로 재사용**: updateComponent에서 기존 경로를 반드시 재사용해야 함
2. **타입 확인**: 자식 매칭 시 타입 확인 필수
3. **Key 사용**: 리스트 렌더링에서는 Key 사용 권장
4. **try-finally**: enterComponent/exitComponent 쌍 보장 필요

---

## 💡 성능 최적화 관점

Reconciliation을 통해 얻는 이점:

1. **DOM 재사용**: 타입/키가 같으면 DOM 재사용
2. **최소 변경**: 변경된 부분만 업데이트
3. **Key 최적화**: Key 사용 시 DOM 이동 최소화
4. **재귀적 처리**: 효율적인 트리 탐색

---

이 명세서는 React의 핵심 렌더링 알고리즘인 Reconciliation을 설명하며, React가 어떻게 효율적으로 DOM을 업데이트하는지 이해하는 기반이 됩니다.

