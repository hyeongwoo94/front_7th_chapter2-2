# 단계 1: React 동작 원리 명세서

## 📋 개요

단계 1은 **React의 Virtual DOM과 JSX 변환 메커니즘**을 설명합니다. React가 어떻게 JSX 코드를 JavaScript 객체로 변환하고, Virtual DOM을 구성하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. Virtual DOM (가상 DOM) 시스템

**원리**: React는 실제 DOM을 직접 조작하지 않고, 메모리상의 JavaScript 객체로 표현된 Virtual DOM을 사용합니다.

**왜 필요한가?**
- 실제 DOM 조작은 비용이 큽니다 (렌더링, 리플로우, 리페인트)
- Virtual DOM으로 변경 사항을 계산한 뒤 한 번에 업데이트하면 성능이 향상됩니다
- 복잡한 UI 상태 관리를 쉽게 할 수 있습니다

**핵심 개념**:
- Virtual DOM은 실제 DOM과 동일한 구조를 가진 JavaScript 객체
- 변경 사항을 Virtual DOM에서 계산한 후 실제 DOM에 최소한의 변경만 적용
- 이 과정을 통해 불필요한 DOM 조작을 최소화

---

### 2. JSX → VNode 변환 메커니즘

**원리**: JSX 문법은 `createElement` 함수 호출로 변환되며, 이는 VNode(Virtual Node) 객체를 생성합니다.

**변환 과정**:
```
JSX 코드
  ↓ (Babel/트랜스파일러)
createElement() 호출
  ↓
VNode 객체 생성
```

**VNode 구조**:
```typescript
{
  type: string | ComponentType | Symbol,  // 요소 타입
  props: {
    children?: VNode[],                   // 자식 노드들
    [key: string]: any                   // 기타 속성
  },
  key?: string | number                  // 리스트 렌더링용 키
}
```

**핵심 개념**:
- JSX는 JavaScript의 확장 문법이지만, 실제로는 함수 호출로 변환됨
- `createElement`는 VNode 트리를 구성하는 핵심 함수
- 빈 값(null, undefined, boolean)은 필터링되어 렌더링되지 않음

---

### 3. 값 비교 전략 (Equality Comparison)

**원리**: React는 효율적인 비교를 위해 얕은 비교(Shallow Comparison)와 깊은 비교(Deep Comparison)를 사용합니다.

**얕은 비교 (shallowEquals)**:
- 1단계 깊이만 비교
- 대부분의 경우에 사용 (useState 의존성, props 비교 등)
- 성능 최적화를 위한 선택

**깊은 비교 (deepEquals)**:
- 모든 중첩 구조를 재귀적으로 비교
- 필요할 때만 사용 (메모이제이션 등)
- 순환 참조 방지 필요

**핵심 개념**:
- React는 기본적으로 얕은 비교를 사용하여 성능 최적화
- 깊은 비교는 비용이 크므로 필요한 경우에만 사용
- `Object.is()`를 기반으로 참조 동일성 확인

---

### 4. 컴포넌트 경로 시스템

**원리**: 각 컴포넌트는 고유한 경로(path)를 가지며, 이 경로는 훅 상태를 격리하는 데 사용됩니다.

**경로 형식**:
- 루트: `"0"`
- key 없음: `"부모경로.c인덱스"` (예: `"0.c0"`, `"0.c1"`)
- key 있음: `"부모경로.i키"` (예: `"0.i1"`, `"0.i2"`)

**핵심 개념**:
- 같은 컴포넌트라도 위치가 다르면 다른 경로를 가짐
- 경로를 통해 각 컴포넌트의 훅 상태를 완전히 격리
- 이는 React Hooks가 동작하는 기반이 됨

---

## 🔄 React 전체 시스템에서의 위치

단계 1은 React의 **기초 인프라**를 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리]
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation]
         ↓
[단계 6: Hook 시스템]
```

**역할**:
- React의 데이터 구조(VNode) 정의
- JSX 변환 메커니즘 제공
- 컴포넌트 식별 시스템 구축
- 이후 단계들의 기반이 되는 인프라

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **JSX 변환**: Babel이 JSX를 `React.createElement()` 호출로 변환
2. **Virtual DOM**: React는 내부적으로 Fiber 노드로 Virtual DOM을 표현
3. **비교 전략**: React는 기본적으로 얕은 비교를 사용하여 최적화
4. **컴포넌트 식별**: React는 내부적으로 각 컴포넌트를 추적하여 상태를 관리

---

## 📚 관련 개념

- **Virtual DOM**: 실제 DOM의 가상 표현
- **VNode**: Virtual DOM의 노드 객체
- **JSX**: JavaScript의 확장 문법
- **createElement**: VNode를 생성하는 함수
- **Shallow Comparison**: 얕은 비교
- **Deep Comparison**: 깊은 비교
- **Component Path**: 컴포넌트 고유 경로

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. Virtual DOM이 무엇이고 왜 필요한지
2. JSX가 어떻게 JavaScript 코드로 변환되는지
3. React가 어떻게 효율적인 비교를 수행하는지
4. 컴포넌트가 어떻게 식별되고 관리되는지

---

이 명세서는 React의 가장 기초가 되는 원리를 설명하며, 이후 모든 단계의 기반이 됩니다.

