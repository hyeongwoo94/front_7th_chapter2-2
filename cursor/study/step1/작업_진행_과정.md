# 단계 1: 작업 진행 과정

Teacher가 단계 1을 구현한 과정을 간결하게 정리합니다.

## 📋 작업 순서

1. **기존 코드 구조 파악** → 함수 시그니처 확인
2. **유틸리티 함수 구현** → equals, validators
3. **핵심 함수 구현** → elements
4. **테스트 실행 및 확인** → 모든 테스트 통과

---

## 🔧 구현 내용

### 1. `isEmptyValue` (`utils/validators.ts`)

**핵심 로직**:

```typescript
return value === null || value === undefined || typeof value === "boolean";
```

**요점**:

- React에서 렌더링되지 않는 값만 필터링
- `0`, `""`은 유효한 값이므로 제외하지 않음

---

### 2. `shallowEquals` (`utils/equals.ts`)

**구현 순서**:

1. `Object.is()`로 참조 동일성 확인
2. null/undefined 체크
3. 타입 비교
4. 배열/객체는 1단계만 비교

**핵심 포인트**:

- `Object.is()` 사용: NaN, +0/-0 케이스 처리
- 중첩 객체는 참조만 비교 (깊은 비교 아님)

---

### 3. `deepEquals` (`utils/equals.ts`)

**구현 순서**:

1. 참조 동일성 확인
2. null/undefined, 타입 체크
3. 순환 참조 방지 (WeakSet 사용)
4. 재귀적으로 모든 속성 비교

**핵심 포인트**:

- **순환 참조 방지**: WeakSet으로 방문한 객체 추적
- **재귀 호출**: 같은 `visited` WeakSet을 재귀 호출에 전달
- **무한 루프 방지**: 이미 방문한 객체는 다시 비교하지 않음

---

### 4. `createTextElement` (`core/elements.ts`)

**역할**: 문자열/숫자를 TEXT_ELEMENT 타입 VNode로 변환

**구조**:

```typescript
{
  type: TEXT_ELEMENT,
  key: null,
  props: { children: [], nodeValue: String(value) }
}
```

---

### 5. `normalizeNode` (`core/elements.ts`)

**처리 순서**:

1. `isEmptyValue`로 필터링 → null 반환
2. 이미 VNode면 그대로 반환
3. 문자열/숫자면 `createTextElement`로 변환

**중요**: 기존 타입 시그니처 `(node: VNode)` 유지, 런타임에 `typeof`로 실제 타입 체크

---

### 6. `createElement` (`core/elements.ts`)

**처리 흐름**:

1. props에서 `key` 추출 (destructuring)
2. children 정규화:
   - 배열이면 재귀적으로 평탄화
   - 각 child를 `normalizeNode`로 변환
   - null 값 필터링
3. VNode 객체 생성

**핵심**:

- children 배열 평탄화 (중첩 배열 처리)
- 모든 child를 VNode로 정규화

---

### 7. `createChildPath` (`core/elements.ts`)

**로직**:

```typescript
if (key !== null && key !== undefined) {
  return `${parentPath}.i${key}`; // key 있음
}
return `${parentPath}.c${index}`; // key 없음
```

**요점**: key가 있으면 무조건 key 사용, 경로 구분자는 `.i` (key), `.c` (index)

---

## ✅ 테스트 결과

```bash
npm test basic.equals.test.tsx
✓ 8 tests passed (8)
```

**통과 항목**:

- shallowEquals: 기본 타입, 배열, 객체 비교, 중첩 구조 얕은 비교
- deepEquals: 기본 타입, 배열, 객체, 중첩 구조 깊은 비교

---

## 🎯 핵심 원칙

### 1. 기존 코드 유지

- 타입 시그니처 변경 금지
- 주석 유지 (`// 여기를 구현하세요.`)
- 기존 코드 구조 유지

### 2. 구현 기법

| 함수            | 핵심 기법                         |
| --------------- | --------------------------------- |
| `shallowEquals` | Object.is(), 1단계 비교           |
| `deepEquals`    | WeakSet 순환 참조 방지, 재귀 호출 |
| `normalizeNode` | 런타임 타입 체크                  |
| `createElement` | 재귀적 배열 평탄화                |

### 3. 타입 처리

- TypeScript 타입과 런타임 타입이 다를 수 있음
- `as unknown`으로 타입 우회 후 `typeof`로 실제 타입 확인
- 기존 시그니처는 유지하면서 내부에서 타입 체크

---

## 📚 학습 요약

### 비교 함수

| 구분      | shallowEquals | deepEquals       |
| --------- | ------------- | ---------------- |
| 비교 깊이 | 1단계만       | 모든 중첩 구조   |
| 중첩 객체 | 참조 비교     | 재귀적 비교      |
| 순환 참조 | 필요 없음     | WeakSet으로 방지 |

### Object.is() vs ===

- `Object.is()`: NaN === NaN, +0 !== -0
- `===`: NaN !== NaN, +0 === -0

### VNode 정규화

- 원시 타입 → TEXT_ELEMENT VNode
- null/undefined/boolean → 필터링
- 배열 → 평탄화 후 정규화

---

## 💡 자주 하는 실수

1. **타입 시그니처 변경**: `(node: VNode)` → `(node: any)` ❌
2. **주석 삭제**: `// 여기를 구현하세요.` 삭제 ❌
3. **shallowEquals에서 깊은 비교**: 중첩 객체를 재귀 비교 ❌
4. **deepEquals에서 순환 참조 미처리**: WeakSet 사용 안 함 ❌

---

다음 단계: **단계 2 - 컨텍스트와 루트 초기화**
