# 단계 3: React 동작 원리 명세서

## 📋 개요

단계 3은 **React의 Virtual DOM을 실제 DOM으로 변환하고 관리하는 메커니즘**을 설명합니다. React가 어떻게 JSX props를 DOM 속성으로 변환하고, 이벤트를 처리하며, DOM을 효율적으로 조작하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. JSX Props → DOM 속성 변환

**원리**: React는 JSX의 props를 실제 DOM 속성으로 변환합니다. 이 과정에서 여러 변환이 필요합니다.

**변환 규칙**:

| JSX Prop | DOM Attribute/Property | 변환 방식 |
|----------|----------------------|----------|
| `onClick` | `click` 이벤트 | `addEventListener`로 등록 |
| `className` | `class` | `setAttribute("class", value)` |
| `htmlFor` | `for` | `setAttribute("for", value)` |
| `style` | `style` 객체 | `Object.assign(dom.style, value)` |
| 일반 속성 | DOM 속성 | 직접 설정 또는 `setAttribute` |

**핵심 개념**:
- React는 JSX의 props를 DOM 속성으로 변환
- 이벤트 핸들러, 스타일, 특수 속성 등 각각 다른 방식으로 처리
- JavaScript 예약어와의 충돌을 피하기 위한 변환 (className, htmlFor)

---

### 2. 이벤트 핸들러 생명주기 관리

**원리**: 이벤트 핸들러는 등록과 제거를 추적해야 합니다. 업데이트 시 이전 핸들러를 제거하고 새 핸들러를 등록해야 합니다.

**등록 과정**:
```typescript
// 이벤트명 변환: onClick → click
const eventType = key.slice(2).toLowerCase();

// 핸들러 저장 (나중에 제거하기 위해)
(dom as any)[`__${eventType}Handler`] = value;

// 이벤트 리스너 등록
dom.addEventListener(eventType, value);
```

**제거 과정**:
```typescript
// 저장된 핸들러 가져오기
const handler = (dom as any)[`__${eventType}Handler`];

// 이벤트 리스너 제거
dom.removeEventListener(eventType, handler);

// 저장된 핸들러 삭제
delete (dom as any)[`__${eventType}Handler`];
```

**핵심 개념**:
- 이벤트 핸들러는 참조를 저장하여 나중에 제거 가능하게 함
- 업데이트 시 이전 핸들러를 제거하고 새 핸들러를 등록
- 메모리 누수 방지

**왜 중요한가?**
- 핸들러를 제거하지 않으면 메모리 누수 발생
- 이전 핸들러가 계속 실행될 수 있음
- React는 항상 최신 핸들러만 실행되도록 보장

---

### 3. 효율적인 속성 업데이트 (Incremental DOM Updates)

**원리**: React는 변경된 속성만 업데이트합니다. 이전 props와 새 props를 비교하여 변경된 것만 DOM에 반영합니다.

**업데이트 전략**:
1. 제거된 속성 처리 (prevProps에만 있는 것)
2. 추가/변경된 속성 처리 (nextProps)
3. 변경되지 않은 속성은 건너뛰기

**비교 로직**:
```typescript
// 변경 감지
if (prevProps[key] === nextProps[key]) {
  continue;  // 변경 안 됨, 건너뛰기
}

// 변경됨, 업데이트 필요
updateProperty(dom, key, nextProps[key]);
```

**핵심 개념**:
- 이전 props와 새 props를 비교
- 변경된 속성만 업데이트
- 불필요한 DOM 조작 최소화

**성능 영향**:
- 모든 속성을 매번 설정하는 것보다 훨씬 효율적
- DOM 조작은 비용이 크므로 최소화가 중요

---

### 4. 복잡한 DOM 구조 처리

**원리**: Instance는 여러 DOM 노드를 가질 수 있습니다 (Fragment, 컴포넌트). 이를 처리하기 위해 재귀적 탐색이 필요합니다.

**DOM 노드 탐색 우선순위**:
1. `instance.dom` (직접 DOM)
2. `instance.children` (자식 인스턴스들)
3. `instance.childInstance` (컴포넌트의 자식)

**탐색 함수**:
- **getDomNodes**: 모든 DOM 노드를 재귀적으로 찾기
- **getFirstDom**: 첫 번째 DOM 노드만 찾기
- **getFirstDomFromChildren**: 자식 인스턴스들에서 첫 DOM 찾기

**핵심 개념**:
- Fragment는 직접 DOM이 없으므로 자식만 탐색
- 컴포넌트는 `childInstance`를 통해 자식 DOM 접근
- 재귀적 탐색으로 모든 DOM 노드 찾기

**사용 사례**:
- Fragment: 여러 DOM 노드를 반환하지만 직접 DOM은 없음
- 컴포넌트: 컴포넌트 자체는 DOM이 없고, 반환된 자식만 DOM을 가짐

---

### 5. DOM 조작 최적화

**원리**: DOM 삽입/제거 시 순서가 중요합니다. 올바른 순서로 조작하지 않으면 인덱스 오류가 발생할 수 있습니다.

**삽입 전략**:
- 순서대로 삽입 (정순)
- Fragment나 컴포넌트는 여러 DOM 노드를 가질 수 있음
- 모든 노드를 순서대로 삽입

**제거 전략**:
- 역순으로 제거 (인덱스 오류 방지)
- DOM에서 제거하면 배열 인덱스가 변경될 수 있음
- 마지막부터 제거하면 안전

**핵심 개념**:
```typescript
// ❌ 정순으로 제거 (문제 있음)
for (let i = 0; i < nodes.length; i++) {
  parentDom.removeChild(nodes[i]);  // 인덱스가 변경될 수 있음
}

// ✅ 역순으로 제거 (안전)
for (let i = nodes.length - 1; i >= 0; i--) {
  parentDom.removeChild(nodes[i]);  // 마지막부터 제거하므로 안전
}
```

---

## 🔄 React 전체 시스템에서의 위치

단계 3은 React의 **DOM 변환 계층**을 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리]
         ↓
[단계 3: DOM 인터페이스] ← 현재 단계
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation] (단계 3 사용)
         ↓
[단계 6: Hook 시스템]
```

**역할**:
- Virtual DOM을 실제 DOM으로 변환하는 인터페이스 제공
- DOM 속성 설정 및 업데이트 처리
- 이벤트 핸들러 관리
- 이후 Reconciliation(단계 5)에서 사용

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **Props 변환**: React는 내부적으로 props를 DOM 속성으로 변환
2. **이벤트 처리**: React는 SyntheticEvent를 사용하여 이벤트를 처리
3. **증분 업데이트**: React는 변경된 부분만 DOM에 반영
4. **DOM 탐색**: React는 Fiber 노드를 통해 DOM 구조를 추적

---

## 📚 관련 개념

- **DOM Manipulation**: DOM 조작
- **Event Handling**: 이벤트 처리
- **Incremental Updates**: 증분 업데이트
- **Synthetic Events**: 합성 이벤트
- **Fragment**: Fragment 컴포넌트
- **Component Instance**: 컴포넌트 인스턴스

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. React가 어떻게 JSX props를 DOM 속성으로 변환하는지
2. 이벤트 핸들러가 어떻게 관리되는지
3. React가 어떻게 효율적으로 DOM을 업데이트하는지
4. Fragment나 컴포넌트의 DOM이 어떻게 처리되는지

---

## ⚠️ 중요한 주의사항

1. **이벤트 핸들러 제거**: 업데이트 시 기존 핸들러를 반드시 제거해야 함
2. **DOM 조작 순서**: 제거는 역순으로 해야 인덱스 오류 방지
3. **부모 확인**: 제거 시 부모가 맞는지 확인 필요
4. **Fragment 처리**: Fragment는 직접 DOM이 없으므로 자식만 처리

---

이 명세서는 React가 Virtual DOM을 실제 DOM으로 변환하고 관리하는 핵심 원리를 설명하며, 효율적인 DOM 조작 메커니즘을 이해하는 기반이 됩니다.

