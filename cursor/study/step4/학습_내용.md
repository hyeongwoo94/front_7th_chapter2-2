# 단계 4: 렌더 스케줄링 - 학습 내용

이 문서는 단계 4에서 학습해야 할 핵심 개념과 구현 내용을 설명합니다.

## 📚 핵심 개념

### 1. 마이크로태스크 큐

마이크로태스크 큐는 동기 코드 실행 후, 브라우저 렌더링 전에 실행되는 비동기 작업 큐입니다.

**실행 순서**:
1. 동기 코드 실행
2. 마이크로태스크 큐 실행
3. 브라우저 렌더링
4. 매크로태스크 큐 실행

**사용 방법**:
- `queueMicrotask()`: 브라우저 표준 API
- `Promise.resolve().then()`: 폴백 방법

**왜 필요한가?**
- 여러 상태 업데이트를 배치 처리
- 렌더링을 한 번만 실행하여 성능 최적화

### 2. 배치 처리 (Batching)

여러 상태 업데이트를 한 번의 렌더링으로 처리하는 기법입니다.

**동작 원리**:
```typescript
setState(1);  // 렌더링 스케줄링
setState(2);  // 이미 스케줄링됨, 무시
setState(3);  // 이미 스케줄링됨, 무시

// 마이크로태스크 큐에서 실행
// render() 한 번만 실행
```

**효과**:
- 불필요한 렌더링 최소화
- 성능 향상

### 3. 렌더링 사이클

렌더링은 다음 순서로 진행됩니다:

```
상태 변경 (setState)
  → enqueueRender()
  → (비동기) render()
    → reconcile()
    → cleanupUnusedHooks()
    → flushEffects()
```

---

## 🔧 구현 함수 상세

### 1. `enqueue(callback)`

**목적**: 마이크로태스크 큐에 작업을 추가합니다.

**구현**:
```typescript
export const enqueue = (callback: () => void) => {
  if (typeof queueMicrotask !== "undefined") {
    queueMicrotask(callback);
  } else {
    Promise.resolve().then(callback);
  }
};
```

**요점**:
- `queueMicrotask` 우선 사용
- 폴백으로 `Promise.resolve().then()` 사용
- 비동기 실행 보장

**예시**:
```typescript
enqueue(() => console.log('async'));
console.log('sync');
// 출력: sync, async
```

---

### 2. `withEnqueue(fn)`

**목적**: 중복 실행을 방지하는 고차 함수입니다.

**구현**:
```typescript
export const withEnqueue = (fn: AnyFunction) => {
  let scheduled = false;
  return ((...args: any[]) => {
    if (scheduled) return;
    scheduled = true;
    enqueue(() => {
      scheduled = false;
      fn(...args);
    });
  }) as AnyFunction;
};
```

**동작 원리**:
1. 첫 호출: `scheduled = true` 설정, 큐에 추가
2. 추가 호출: `scheduled = true`이므로 무시
3. 실행 후: `scheduled = false`로 리셋

**요점**:
- 중복 실행 방지: `scheduled` 플래그로 제어
- 실행 후 리셋: 다음 호출을 위해 플래그 초기화

**예시**:
```typescript
const scheduledFunc = withEnqueue(() => {
  console.log('rendered');
});

scheduledFunc(); // 스케줄링
scheduledFunc(); // 무시
scheduledFunc(); // 무시
// 실제로는 한 번만 실행됨
```

---

### 3. `render()`

**목적**: 루트 컴포넌트를 렌더링합니다.

**처리 순서**:
1. 훅 컨텍스트 초기화 (visited, componentStack)
2. reconcile 함수 호출 (루트 노드 재조정)
3. 사용되지 않은 훅 정리 (cleanupUnusedHooks)
4. 이펙트 실행 (flushEffects)

**구현**:
```typescript
export const render = (): void => {
  // 1. 훅 컨텍스트를 초기화합니다.
  context.hooks.visited.clear();
  context.hooks.componentStack = [];

  // 2. reconcile 함수를 호출하여 루트 노드를 재조정합니다.
  if (context.root.container && context.root.node !== null) {
    const instance = reconcile(
      context.root.container,
      context.root.instance,
      context.root.node,
      "0"
    );
    context.root.instance = instance;
  }

  // 3. 사용되지 않은 훅들을 정리합니다.
  cleanupUnusedHooks();

  // 4. 이펙트 실행
  flushEffects();
};
```

**요점**:
- visited 초기화: 매 렌더링마다 새로 시작
- componentStack 초기화: 컴포넌트 실행 스택 초기화
- reconcile 호출: 루트 노드를 재조정하여 DOM 업데이트
- 훅 정리: 미사용 훅 상태 및 클린업 함수 제거
- 이펙트 실행: 예약된 이펙트들을 비동기로 실행

---

### 4. `enqueueRender()`

**목적**: 렌더링을 스케줄링합니다.

**구현**:
```typescript
export const enqueueRender = withEnqueue(render);
```

**요점**:
- `withEnqueue`로 래핑: 중복 렌더링 방지
- 배치 처리: 여러 상태 업데이트를 한 번의 렌더링으로 처리
- 비동기 실행: 마이크로태스크 큐에서 실행

**사용 예**:
```typescript
// useState setter에서 호출
setState(newValue);      // enqueueRender() 호출
setState(anotherValue);  // 무시됨 (이미 스케줄링됨)
// 실제로는 한 번만 렌더링
```

---

## 💡 핵심 원칙

### 1. 마이크로태스크 큐

- **queueMicrotask**: 브라우저에서 제공하는 마이크로태스크 큐
- **Promise.resolve().then()**: 폴백 방법
- **실행 순서**: 동기 코드 후, 렌더링 전 실행

### 2. 배치 처리 (Batching)

- **목적**: 여러 상태 업데이트를 한 번의 렌더링으로 처리
- **방법**: `withEnqueue`로 중복 실행 방지
- **성능**: 불필요한 렌더링 최소화

### 3. 렌더링 사이클

```
상태 변경 (setState)
  → enqueueRender()
  → (비동기) render()
    → reconcile()
    → cleanupUnusedHooks()
    → flushEffects()
```

### 4. scheduled 플래그

- **목적**: 중복 스케줄링 방지
- **초기값**: false
- **설정 시점**: 첫 호출 시 true
- **리셋 시점**: 실행 후 false

---

## 🎯 실습 예시

### 예시 1: 배치 처리

```typescript
function Component() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  
  const handleClick = () => {
    setA(1);  // enqueueRender() 호출
    setB(2);  // 이미 스케줄링됨, 무시
    setA(3);  // 이미 스케줄링됨, 무시
    // 실제로는 한 번만 렌더링
  };
}
```

### 예시 2: 마이크로태스크 큐

```typescript
console.log('1');
enqueue(() => console.log('2'));
console.log('3');
// 출력: 1, 3, 2
```

### 예시 3: 렌더링 플로우

```typescript
// 상태 변경
setState(1);
  → enqueueRender()
    → (비동기) render()
      → reconcile()  // DOM 업데이트
      → cleanupUnusedHooks()  // 미사용 훅 정리
      → flushEffects()  // 이펙트 실행
```

---

## ⚠️ 주의사항

1. **동기 실행**: `enqueue`를 동기로 실행하면 배치 처리 실패 ❌
2. **플래그 리셋 누락**: `scheduled` 플래그를 리셋하지 않으면 다음 렌더링 불가 ❌
3. **컨텍스트 접근**: `render`에서 전역 `context` 접근 필요 ✅
4. **에러 처리**: 렌더링 중 에러 발생 시에도 플래그 리셋 (try-finally 권장) ✅

---

## 💡 자주 하는 실수

### 1. 동기 실행

```typescript
// ❌ 잘못된 예
const enqueue = (callback: () => void) => {
  callback();  // 동기 실행!
};

// ✅ 올바른 예
const enqueue = (callback: () => void) => {
  queueMicrotask(callback);  // 비동기 실행
};
```

### 2. 플래그 리셋 누락

```typescript
// ❌ 잘못된 예
enqueue(() => {
  fn(...args);
  // scheduled = false로 리셋 안 함!
});

// ✅ 올바른 예
enqueue(() => {
  scheduled = false;
  fn(...args);
});
```

### 3. 에러 처리 누락

```typescript
// ❌ 잘못된 예
enqueue(() => {
  fn(...args);  // 에러 발생 시 플래그 리셋 안 됨
});

// ✅ 올바른 예
enqueue(() => {
  try {
    fn(...args);
  } finally {
    scheduled = false;  // 항상 리셋
  }
});
```

---

## 🔄 다음 단계

이제 렌더 스케줄링이 완료되었습니다. 다음 단계에서는 Reconciliation을 구현합니다.

**다음 단계**: [단계 5 - Reconciliation](../step5/학습_내용.md)

