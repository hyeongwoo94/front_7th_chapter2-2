# 단계 4: React 동작 원리 명세서

## 📋 개요

단계 4는 **React의 렌더링 스케줄링과 배치 처리 메커니즘**을 설명합니다. React가 어떻게 여러 상태 업데이트를 배치 처리하고, 비동기로 렌더링을 수행하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. 마이크로태스크 큐 (Microtask Queue)

**원리**: React는 마이크로태스크 큐를 사용하여 렌더링을 비동기로 처리합니다. 이를 통해 여러 상태 업데이트를 한 번의 렌더링으로 배치 처리할 수 있습니다.

**실행 순서**:
1. 동기 코드 실행
2. 마이크로태스크 큐 실행
3. 브라우저 렌더링
4. 매크로태스크 큐 실행

**구현 방법**:
```typescript
// 방법 1: queueMicrotask (표준)
queueMicrotask(callback);

// 방법 2: Promise.resolve().then() (폴백)
Promise.resolve().then(callback);
```

**핵심 개념**:
- 마이크로태스크는 동기 코드 실행 후, 브라우저 렌더링 전에 실행됨
- 여러 상태 업데이트를 배치 처리할 수 있음
- 불필요한 렌더링을 최소화하여 성능 향상

**왜 필요한가?**
- 여러 `setState` 호출을 한 번의 렌더링으로 처리
- 브라우저 렌더링 전에 모든 상태 업데이트 완료
- 사용자 경험 향상 (깜빡임 최소화)

---

### 2. 배치 처리 (Batching)

**원리**: 여러 상태 업데이트를 한 번의 렌더링으로 처리하는 기법입니다. `scheduled` 플래그를 사용하여 중복 실행을 방지합니다.

**동작 원리**:
```typescript
// 첫 번째 setState
setState(1);
  → enqueueRender() 호출
  → scheduled = true 설정
  → 마이크로태스크 큐에 추가

// 두 번째 setState (같은 렌더링 사이클 내)
setState(2);
  → enqueueRender() 호출
  → scheduled = true이므로 무시

// 세 번째 setState
setState(3);
  → enqueueRender() 호출
  → scheduled = true이므로 무시

// 마이크로태스크 큐에서 실행
render() 한 번만 실행
  → scheduled = false로 리셋
```

**핵심 개념**:
- `scheduled` 플래그로 중복 실행 방지
- 여러 상태 업데이트를 한 번의 렌더링으로 처리
- 성능 최적화

**효과**:
- 불필요한 렌더링 최소화
- DOM 조작 횟수 감소
- 전체적인 성능 향상

---

### 3. 렌더링 사이클 (Render Cycle)

**원리**: 렌더링은 다음 순서로 진행됩니다:

```
상태 변경 (setState)
  ↓
enqueueRender()  (스케줄링)
  ↓
(비동기) render()
  ├─ 훅 컨텍스트 초기화
  ├─ reconcile()  (DOM 업데이트)
  ├─ cleanupUnusedHooks()  (미사용 훅 정리)
  └─ flushEffects()  (이펙트 실행)
```

**각 단계 설명**:

1. **훅 컨텍스트 초기화**
   - `visited` Set 초기화
   - `componentStack` 초기화
   - 매 렌더링마다 새로 시작

2. **reconcile (재조정)**
   - 이전 Virtual DOM과 새 Virtual DOM 비교
   - 변경된 부분만 실제 DOM에 반영
   - 최소한의 DOM 조작

3. **cleanupUnusedHooks (미사용 훅 정리)**
   - 방문하지 않은 컴포넌트의 훅 정리
   - useEffect 클린업 함수 실행
   - 메모리 누수 방지

4. **flushEffects (이펙트 실행)**
   - 예약된 useEffect 실행
   - 비동기로 실행
   - 클린업 함수 저장

**핵심 개념**:
- 렌더링은 여러 단계로 구성됨
- 각 단계는 특정 목적을 가짐
- 순서가 중요함

---

### 4. 중복 실행 방지 메커니즘

**원리**: `withEnqueue` 고차 함수를 사용하여 중복 실행을 방지합니다.

**구현**:
```typescript
export const withEnqueue = (fn: AnyFunction) => {
  let scheduled = false;
  return ((...args: any[]) => {
    if (scheduled) return;  // 이미 스케줄링됨, 무시
    scheduled = true;
    enqueue(() => {
      scheduled = false;  // 실행 후 리셋
      fn(...args);
    });
  }) as AnyFunction;
};
```

**동작 흐름**:
1. 첫 호출: `scheduled = false` → `scheduled = true` 설정 → 큐에 추가
2. 추가 호출: `scheduled = true` → 무시
3. 실행 후: `scheduled = false`로 리셋 → 다음 호출 가능

**핵심 개념**:
- `scheduled` 플래그로 중복 방지
- 실행 후 반드시 리셋해야 함
- 에러 발생 시에도 리셋 필요 (try-finally 권장)

---

## 🔄 React 전체 시스템에서의 위치

단계 4는 React의 **렌더링 스케줄링 계층**을 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리]
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링] ← 현재 단계
         ↓
[단계 5: Reconciliation] (단계 4에서 호출)
         ↓
[단계 6: Hook 시스템] (단계 4에서 사용)
```

**역할**:
- 렌더링을 비동기로 스케줄링
- 여러 상태 업데이트를 배치 처리
- 렌더링 사이클 관리
- 이후 단계들의 실행 순서 제어

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **배치 처리**: React 18에서는 자동 배치 처리가 기본 동작
2. **스케줄링**: React는 내부적으로 스케줄러를 사용하여 우선순위 관리
3. **마이크로태스크**: React는 마이크로태스크 큐를 활용하여 렌더링 최적화
4. **렌더링 사이클**: React는 여러 단계로 렌더링을 수행

---

## 📚 관련 개념

- **Microtask Queue**: 마이크로태스크 큐
- **Batching**: 배치 처리
- **Render Scheduling**: 렌더 스케줄링
- **Async Rendering**: 비동기 렌더링
- **Render Cycle**: 렌더링 사이클
- **Event Loop**: 이벤트 루프

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. React가 어떻게 여러 상태 업데이트를 배치 처리하는지
2. 마이크로태스크 큐가 어떻게 사용되는지
3. 렌더링 사이클이 어떻게 구성되는지
4. 중복 실행 방지 메커니즘이 어떻게 동작하는지

---

## ⚠️ 중요한 주의사항

1. **비동기 실행**: `enqueue`는 반드시 비동기로 실행해야 함
2. **플래그 리셋**: `scheduled` 플래그를 반드시 리셋해야 함
3. **에러 처리**: 에러 발생 시에도 플래그 리셋 필요
4. **실행 순서**: 렌더링 사이클의 순서가 중요함

---

## 💡 성능 최적화 관점

배치 처리를 통해 얻는 이점:

1. **렌더링 횟수 감소**: 여러 상태 업데이트를 한 번의 렌더링으로 처리
2. **DOM 조작 최소화**: 불필요한 DOM 업데이트 방지
3. **사용자 경험 향상**: 깜빡임 최소화
4. **성능 향상**: 전체적인 렌더링 비용 감소

---

이 명세서는 React가 렌더링을 스케줄링하고 배치 처리하는 핵심 원리를 설명하며, 효율적인 렌더링 메커니즘을 이해하는 기반이 됩니다.

