# 단계 4: 작업 진행 과정

Teacher가 단계 4를 구현한 과정을 간결하게 정리합니다.

## 📋 작업 순서

1. **기존 코드 구조 파악** → 함수 시그니처 확인
2. **마이크로태스크 큐 구현** → enqueue, withEnqueue
3. **렌더링 함수 구현** → render, enqueueRender

---

## 🔧 구현 내용

### 1. `enqueue` (`utils/enqueue.ts`)

**구현**:

```typescript
export const enqueue = (callback: () => void) => {
  if (typeof queueMicrotask !== "undefined") {
    queueMicrotask(callback);
  } else {
    Promise.resolve().then(callback);
  }
};
```

**핵심 포인트**:

- **마이크로태스크 큐 사용**: `queueMicrotask` 우선 사용
- **폴백**: `Promise.resolve().then()` 사용
- **비동기 실행**: 동기 코드 실행 후 실행됨

**예시**:
```typescript
enqueue(() => console.log('async'));
console.log('sync');
// 출력: sync, async
```

---

### 2. `withEnqueue` (`utils/enqueue.ts`)

**구현**:

```typescript
export const withEnqueue = (fn: AnyFunction) => {
  let scheduled = false;
  return ((...args: any[]) => {
    if (scheduled) return;
    scheduled = true;
    enqueue(() => {
      scheduled = false;
      fn(...args);
    });
  }) as AnyFunction;
};
```

**핵심 포인트**:

- **중복 실행 방지**: `scheduled` 플래그로 제어
- **첫 호출 시 스케줄링**: `scheduled = true` 설정
- **실행 후 리셋**: `scheduled = false`로 초기화
- **이미 스케줄링된 경우 무시**: 중복 호출 방지

**예시**:
```typescript
const scheduledFunc = withEnqueue(() => {
  console.log('rendered');
});

scheduledFunc(); // 스케줄링
scheduledFunc(); // 무시
scheduledFunc(); // 무시
// 실제로는 한 번만 실행됨
```

---

### 3. `render` (`core/render.ts`)

**처리 순서**:

1. 훅 컨텍스트 초기화 (visited, componentStack)
2. reconcile 함수 호출 (루트 노드 재조정)
3. 사용되지 않은 훅 정리 (cleanupUnusedHooks)
4. 이펙트 실행 (flushEffects)

**구현**:

```typescript
export const render = (): void => {
  // 1. 훅 컨텍스트를 초기화합니다.
  context.hooks.visited.clear();
  context.hooks.componentStack = [];

  // 2. reconcile 함수를 호출하여 루트 노드를 재조정합니다.
  if (context.root.container && context.root.node !== null) {
    const instance = reconcile(
      context.root.container,
      context.root.instance,
      context.root.node,
      "0"
    );
    context.root.instance = instance;
  }

  // 3. 사용되지 않은 훅들을 정리합니다.
  cleanupUnusedHooks();

  // 4. 이펙트 실행
  flushEffects();
};
```

**핵심 포인트**:

- **visited 초기화**: 매 렌더링마다 새로 시작
- **componentStack 초기화**: 컴포넌트 실행 스택 초기화
- **reconcile 호출**: 루트 노드를 재조정하여 DOM 업데이트
- **훅 정리**: 미사용 훅 상태 및 클린업 함수 제거
- **이펙트 실행**: 예약된 이펙트들을 비동기로 실행

---

### 4. `enqueueRender` (`core/render.ts`)

**구현**:

```typescript
export const enqueueRender = withEnqueue(render);
```

**핵심 포인트**:

- **withEnqueue로 래핑**: 중복 렌더링 방지
- **배치 처리**: 여러 상태 업데이트를 한 번의 렌더링으로 처리
- **비동기 실행**: 마이크로태스크 큐에서 실행

**사용 예**:
```typescript
// useState setter에서 호출
setState(newValue);      // enqueueRender() 호출
setState(anotherValue);  // 무시됨 (이미 스케줄링됨)
// 실제로는 한 번만 렌더링
```

---

## ✅ 테스트 확인

이 단계만으로는 독립적인 테스트가 없음. 다음 단계들과 함께 테스트 통과.

**확인 사항**:

- `enqueue`가 비동기로 실행되는지
- `withEnqueue`가 중복 실행을 방지하는지
- `enqueueRender`가 배치 처리를 하는지

**테스트 예시**:
```typescript
let count = 0;
const func = withEnqueue(() => count++);

func();
func();
func();
// count는 1이 되어야 함
```

---

## 🎯 핵심 원칙

### 1. 마이크로태스크 큐

- **queueMicrotask**: 브라우저에서 제공하는 마이크로태스크 큐
- **Promise.resolve().then()**: 폴백 방법
- **실행 순서**: 동기 코드 후, 렌더링 전 실행

### 2. 배치 처리 (Batching)

- **목적**: 여러 상태 업데이트를 한 번의 렌더링으로 처리
- **방법**: `withEnqueue`로 중복 실행 방지
- **성능**: 불필요한 렌더링 최소화

### 3. 렌더링 사이클

```
상태 변경 (setState)
  → enqueueRender()
  → (비동기) render()
    → reconcile()
    → cleanupUnusedHooks()
    → flushEffects()
```

### 4. scheduled 플래그

- **목적**: 중복 스케줄링 방지
- **초기값**: false
- **설정 시점**: 첫 호출 시 true
- **리셋 시점**: 실행 후 false

---

## 📚 학습 요약

### 마이크로태스크 큐

| 방법 | 사용 시점 | 특징 |
|------|----------|------|
| `queueMicrotask()` | 브라우저 지원 시 | 표준 방법 |
| `Promise.resolve().then()` | 폴백 | 호환성 보장 |

### 배치 처리 동작

```typescript
// 여러 상태 업데이트
setState(1);  // scheduled = true
setState(2);  // 이미 스케줄링됨, 무시
setState(3);  // 이미 스케줄링됨, 무시

// 마이크로태스크 큐에서 실행
// render() 한 번만 실행
```

### 렌더링 플로우

1. **초기화**: visited, componentStack 초기화
2. **재조정**: reconcile로 DOM 업데이트
3. **정리**: 미사용 훅 제거
4. **이펙트**: 예약된 이펙트 실행

---

## 💡 자주 하는 실수

1. **동기 실행**: `enqueue`를 동기로 실행하면 배치 처리 실패 ❌
2. **플래그 리셋 누락**: `scheduled` 플래그를 리셋하지 않으면 다음 렌더링 불가 ❌
3. **컨텍스트 접근**: `render`에서 전역 `context` 접근 필요 ✅
4. **에러 처리**: 렌더링 중 에러 발생 시에도 플래그 리셋 (try-finally 권장) ✅

---

다음 단계: **단계 5 - Reconciliation**

