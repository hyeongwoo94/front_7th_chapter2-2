# ë‹¨ê³„ 7: ì‘ì—… ì§„í–‰ ê³¼ì •

Teacherê°€ ë‹¨ê³„ 7ì„ êµ¬í˜„í•œ ê³¼ì •ì„ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•©ë‹ˆë‹¤.

## ğŸ“‹ ì‘ì—… ìˆœì„œ

1. **ê¸°ì¡´ ì½”ë“œ êµ¬ì¡° íŒŒì•…** â†’ hooks, hocs íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ í™•ì¸
2. **useRef êµ¬í˜„** â†’ ì°¸ì¡° ê°ì²´ í›…
3. **useMemo êµ¬í˜„** â†’ ë©”ëª¨ì´ì œì´ì…˜ í›…
4. **useCallback êµ¬í˜„** â†’ ì½œë°± ë©”ëª¨ì´ì œì´ì…˜ í›…
5. **useDeepMemo, useAutoCallback êµ¬í˜„** â†’ í™•ì¥ í›…
6. **memo, deepMemo êµ¬í˜„** â†’ ê³ ì°¨ ì»´í¬ë„ŒíŠ¸

---

## ğŸ”§ êµ¬í˜„ ë‚´ìš©

### 1. `useRef` (`hooks/useRef.ts`)

**êµ¬í˜„**:

```typescript
export const useRef = <T>(initialValue: T): { current: T } => {
  const [ref] = useState(() => ({ current: initialValue }));
  return ref;
};
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **useState í™œìš©**: ref ê°ì²´ë¥¼ í•œ ë²ˆë§Œ ìƒì„±í•˜ë„ë¡ í•¨
- **í•¨ìˆ˜í˜• ì´ˆê¸°ê°’**: ì´ˆê¸°í™” í•¨ìˆ˜ë¡œ ref ê°ì²´ ìƒì„±
- **ì¬ë Œë”ë§ ë³´ì¡´**: ref ê°ì²´ëŠ” ì¬ë Œë”ë§ë˜ì–´ë„ ìœ ì§€ë¨

**ì˜ˆì‹œ**:

```typescript
const ref = useRef(0);
ref.current = 1; // ì¬ë Œë”ë§ ì•ˆ í•¨
```

---

### 2. `useMemo` (`hooks/useMemo.ts`)

**êµ¬í˜„**:

```typescript
export const useMemo = <T>(factory: () => T, deps: DependencyList, equals = shallowEquals): T => {
  const ref = useRef<{ value: T; deps: DependencyList } | null>(null);

  if (!ref.current || !equals(ref.current.deps, deps)) {
    ref.current = { value: factory(), deps };
  }

  return ref.current.value;
};
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **useRef í™œìš©**: ì´ì „ ì˜ì¡´ì„± ë°°ì—´ê³¼ ê³„ì‚°ëœ ê°’ ì €ì¥
- **ì˜ì¡´ì„± ë¹„êµ**: `equals` í•¨ìˆ˜ë¡œ ì˜ì¡´ì„± ë¹„êµ
- **ì¡°ê±´ë¶€ ì‹¤í–‰**: ì˜ì¡´ì„±ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ factory ì‹¤í–‰
- **ì»¤ìŠ¤í…€ equals**: ê¸°ë³¸ê°’ì€ `shallowEquals`, ì»¤ìŠ¤í…€ ë¹„êµ í•¨ìˆ˜ ì‚¬ìš© ê°€ëŠ¥

**ì˜ˆì‹œ**:

```typescript
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

---

### 3. `useCallback` (`hooks/useCallback.ts`)

**êµ¬í˜„**:

```typescript
export const useCallback = <T extends (...args: any[]) => any>(callback: T, deps: DependencyList): T => {
  return useMemo(() => callback, deps);
};
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **useMemo í™œìš©**: í•¨ìˆ˜ë¥¼ ë©”ëª¨ì´ì œì´ì…˜
- **ê°„ë‹¨í•œ êµ¬í˜„**: useMemoë¡œ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” factoryë¡œ ë˜í•‘

**ì˜ˆì‹œ**:

```typescript
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);
```

---

### 4. `useDeepMemo` (`hooks/useDeepMemo.ts`)

**êµ¬í˜„**:

```typescript
export const useDeepMemo = <T>(factory: () => T, deps: DependencyList): T => {
  return useMemo(factory, deps, deepEquals);
};
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **useMemo í™œìš©**: `deepEquals`ë¥¼ ë¹„êµ í•¨ìˆ˜ë¡œ ì‚¬ìš©
- **ê¹Šì€ ë¹„êµ**: ì˜ì¡´ì„± ë°°ì—´ì„ ê¹Šê²Œ ë¹„êµ

**ì˜ˆì‹œ**:

```typescript
const value = useDeepMemo(() => {
  return computeValue(obj);
}, [obj]); // obj ë‚´ë¶€ ì†ì„± ë³€ê²½ ê°ì§€
```

---

### 5. `useAutoCallback` (`hooks/useAutoCallback.ts`)

**êµ¬í˜„**:

```typescript
export const useAutoCallback = <T extends AnyFunction>(fn: T): T => {
  const ref = useRef(fn);

  // í•­ìƒ ìµœì‹  í•¨ìˆ˜ë¡œ ì—…ë°ì´íŠ¸
  ref.current = fn;

  return useCallback((...args: Parameters<T>) => {
    return ref.current(...args);
  }, []) as T;
};
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **refë¡œ ìµœì‹  í•¨ìˆ˜ ì €ì¥**: í•­ìƒ ìµœì‹  í•¨ìˆ˜ ì°¸ì¡°
- **useCallbackìœ¼ë¡œ ì•ˆì •ì  ì°¸ì¡°**: ë˜í¼ í•¨ìˆ˜ëŠ” ì¬ìƒì„± ì•ˆ í•¨
- **ìë™ ì—…ë°ì´íŠ¸**: í•¨ìˆ˜ê°€ ë³€ê²½ë˜ì–´ë„ ìë™ìœ¼ë¡œ ìµœì‹  í•¨ìˆ˜ í˜¸ì¶œ

**ì˜ˆì‹œ**:

```typescript
const handleClick = useAutoCallback(() => {
  console.log(count); // í•­ìƒ ìµœì‹  count ì°¸ì¡°
});
// handleClick ì°¸ì¡°ëŠ” ë³€í•˜ì§€ ì•ŠìŒ
```

---

### 6. `memo` (`hocs/memo.ts`)

**êµ¬í˜„**:

```typescript
export function memo<P extends object>(Component: FunctionComponent<P>, equals = shallowEquals) {
  const MemoizedComponent: FunctionComponent<P> = (props) => {
    const ref = useRef<{ props: P; result: VNode | null } | null>(null);

    if (!ref.current || !equals(ref.current.props, props)) {
      ref.current = { props, result: Component(props) };
    }

    return ref.current.result!;
  };

  MemoizedComponent.displayName = `Memo(${Component.displayName || Component.name})`;

  return MemoizedComponent;
}
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **useRef í™œìš©**: ì´ì „ propsì™€ ë Œë”ë§ ê²°ê³¼ ì €ì¥
- **props ë¹„êµ**: `equals` í•¨ìˆ˜ë¡œ props ë¹„êµ
- **ì¡°ê±´ë¶€ ë Œë”ë§**: propsê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ì»´í¬ë„ŒíŠ¸ ì¬ì‹¤í–‰
- **ì»¤ìŠ¤í…€ equals**: ê¸°ë³¸ê°’ì€ `shallowEquals`, ì»¤ìŠ¤í…€ ë¹„êµ í•¨ìˆ˜ ì‚¬ìš© ê°€ëŠ¥

**ì˜ˆì‹œ**:

```typescript
const MemoizedComponent = memo(MyComponent);
// propsê°€ ê°™ìœ¼ë©´ ì¬ë Œë”ë§ ì•ˆ í•¨
```

---

### 7. `deepMemo` (`hocs/deepMemo.ts`)

**êµ¬í˜„**:

```typescript
export function deepMemo<P extends object>(Component: FunctionComponent<P>) {
  return memo(Component, deepEquals);
}
```

**í•µì‹¬ í¬ì¸íŠ¸**:

- **memo í™œìš©**: `deepEquals`ë¥¼ ë¹„êµ í•¨ìˆ˜ë¡œ ì‚¬ìš©
- **ê¹Šì€ ë¹„êµ**: propsë¥¼ ê¹Šê²Œ ë¹„êµ

**ì˜ˆì‹œ**:

```typescript
const MemoizedComponent = deepMemo(MyComponent);
// propsë¥¼ ê¹Šê²Œ ë¹„êµí•˜ì—¬ ì¬ë Œë”ë§ ì—¬ë¶€ ê²°ì •
```

---

## âœ… í…ŒìŠ¤íŠ¸ í™•ì¸

ì´ ë‹¨ê³„ê°€ ì™„ë£Œë˜ë©´ ë‹¤ìŒ í…ŒìŠ¤íŠ¸ê°€ í†µê³¼í•´ì•¼ í•©ë‹ˆë‹¤:

```bash
npm test advanced.hooks.test.tsx
npm test advanced.hoc.test.tsx
```

**í…ŒìŠ¤íŠ¸ í•­ëª©**:

- `useRef` ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- `useMemo` ë©”ëª¨ì´ì œì´ì…˜ í…ŒìŠ¤íŠ¸
- `useCallback` ë©”ëª¨ì´ì œì´ì…˜ í…ŒìŠ¤íŠ¸
- `memo` ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜ í…ŒìŠ¤íŠ¸
- ì˜ì¡´ì„± ë¹„êµ í…ŒìŠ¤íŠ¸

---

## ğŸ¯ í•µì‹¬ ì›ì¹™

### 1. ë©”ëª¨ì´ì œì´ì…˜ íŒ¨í„´

| í›…/HOC        | ëª©ì                               | ë¹„êµ í•¨ìˆ˜              |
| ------------- | --------------------------------- | ---------------------- |
| `useMemo`     | ê°’ ë©”ëª¨ì´ì œì´ì…˜                   | `shallowEquals` (ê¸°ë³¸) |
| `useCallback` | í•¨ìˆ˜ ë©”ëª¨ì´ì œì´ì…˜                 | `shallowEquals` (ê¸°ë³¸) |
| `useDeepMemo` | ê°’ ë©”ëª¨ì´ì œì´ì…˜ (ê¹Šì€ ë¹„êµ)       | `deepEquals`           |
| `memo`        | ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜             | `shallowEquals` (ê¸°ë³¸) |
| `deepMemo`    | ì»´í¬ë„ŒíŠ¸ ë©”ëª¨ì´ì œì´ì…˜ (ê¹Šì€ ë¹„êµ) | `deepEquals`           |

### 2. useRef í™œìš©

- **ìƒíƒœ ì €ì¥**: ì´ì „ ê°’ì´ë‚˜ ê³„ì‚° ê²°ê³¼ ì €ì¥
- **ì¬ë Œë”ë§ ë³´ì¡´**: refëŠ” ì¬ë Œë”ë§ë˜ì–´ë„ ìœ ì§€ë¨
- **í•¨ìˆ˜í˜• ì´ˆê¸°ê°’**: ì´ˆê¸°í™” ì‹œì—ë§Œ ì‹¤í–‰

### 3. ì˜ì¡´ì„± ë¹„êµ

- **shallowEquals**: 1ë‹¨ê³„ ê¹Šì´ë§Œ ë¹„êµ (ê¸°ë³¸)
- **deepEquals**: ëª¨ë“  ì¤‘ì²© êµ¬ì¡° ë¹„êµ
- **ì»¤ìŠ¤í…€ equals**: ì‚¬ìš©ì ì •ì˜ ë¹„êµ í•¨ìˆ˜ ì‚¬ìš© ê°€ëŠ¥

### 4. HOC íŒ¨í„´

- **ì»´í¬ë„ŒíŠ¸ ë˜í•‘**: ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ë¥¼ ìƒˆë¡œìš´ ì»´í¬ë„ŒíŠ¸ë¡œ ë˜í•‘
- **props ë¹„êµ**: ì´ì „ propsì™€ í˜„ì¬ props ë¹„êµ
- **ì¡°ê±´ë¶€ ë Œë”ë§**: propsê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ì¬ë Œë”ë§

---

## ğŸ“š í•™ìŠµ ìš”ì•½

### useMemo ë™ì‘

```typescript
// ì²« ë Œë”ë§
const value = useMemo(() => compute(a, b), [a, b]);
  â†’ ref.current = null
  â†’ compute(a, b) ì‹¤í–‰
  â†’ ref.current = { value: result, deps: [a, b] }

// ë‘ ë²ˆì§¸ ë Œë”ë§ (ì˜ì¡´ì„± ë³€ê²½ ì•ˆ ë¨)
const value = useMemo(() => compute(a, b), [a, b]);
  â†’ shallowEquals([a, b], [a, b]) = true
  â†’ compute() ì‹¤í–‰ ì•ˆ í•¨
  â†’ ref.current.value ë°˜í™˜

// ì„¸ ë²ˆì§¸ ë Œë”ë§ (ì˜ì¡´ì„± ë³€ê²½ë¨)
const value = useMemo(() => compute(a, c), [a, c]);
  â†’ shallowEquals([a, b], [a, c]) = false
  â†’ compute(a, c) ì‹¤í–‰
  â†’ ref.current = { value: newResult, deps: [a, c] }
```

### useAutoCallback ë™ì‘

```typescript
// ì²« ë Œë”ë§
const handleClick = useAutoCallback(() => console.log(count));
  â†’ ref.current = fn1
  â†’ useCallbackìœ¼ë¡œ ë˜í¼ ìƒì„±

// ë‘ ë²ˆì§¸ ë Œë”ë§ (count ë³€ê²½)
const handleClick = useAutoCallback(() => console.log(count));
  â†’ ref.current = fn2 (ìµœì‹  í•¨ìˆ˜ë¡œ ì—…ë°ì´íŠ¸)
  â†’ useCallbackì˜ depsëŠ” []ì´ë¯€ë¡œ ë˜í¼ëŠ” ì¬ìƒì„± ì•ˆ ë¨
  â†’ handleClick ì°¸ì¡°ëŠ” ë™ì¼

// í˜¸ì¶œ ì‹œ
handleClick();
  â†’ ref.current(...args) í˜¸ì¶œ
  â†’ í•­ìƒ ìµœì‹  í•¨ìˆ˜(fn2) ì‹¤í–‰
```

### memo ë™ì‘

```typescript
// ì²« ë Œë”ë§
const Memoized = memo(Component);
<Memoized count={1} />
  â†’ ref.current = null
  â†’ Component({ count: 1 }) ì‹¤í–‰
  â†’ ref.current = { props: { count: 1 }, result: vnode }

// ë‘ ë²ˆì§¸ ë Œë”ë§ (props ë³€ê²½ ì•ˆ ë¨)
<Memoized count={1} />
  â†’ shallowEquals({ count: 1 }, { count: 1 }) = true
  â†’ Component() ì‹¤í–‰ ì•ˆ í•¨
  â†’ ref.current.result ë°˜í™˜

// ì„¸ ë²ˆì§¸ ë Œë”ë§ (props ë³€ê²½ë¨)
<Memoized count={2} />
  â†’ shallowEquals({ count: 1 }, { count: 2 }) = false
  â†’ Component({ count: 2 }) ì‹¤í–‰
  â†’ ref.current = { props: { count: 2 }, result: newVnode }
```

---

## ğŸ’¡ ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜

1. **useRef ì´ˆê¸°í™”**: í•¨ìˆ˜í˜• ì´ˆê¸°ê°’ì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ë§¤ ë Œë”ë§ë§ˆë‹¤ ìƒˆ ê°ì²´ ìƒì„± âŒ
2. **ì˜ì¡´ì„± ëˆ„ë½**: useMemo/useCallbackì—ì„œ ì˜ì¡´ì„± ë°°ì—´ ëˆ„ë½ âŒ
3. **equals í•¨ìˆ˜ ì„ íƒ**: shallowEquals vs deepEquals ì„ íƒ ì‹¤ìˆ˜ âŒ
4. **memo props ë¹„êµ**: propsë¥¼ ì§ì ‘ ë¹„êµí•˜ì§€ ì•Šê³  refì— ì €ì¥ âŒ
5. **useAutoCallback ref ì—…ë°ì´íŠ¸**: ref.currentë¥¼ ì—…ë°ì´íŠ¸ ì•ˆ í•˜ë©´ ìµœì‹  í•¨ìˆ˜ ì°¸ì¡° ì•ˆ ë¨ âŒ

---

ëª¨ë“  ë‹¨ê³„ êµ¬í˜„ ì™„ë£Œ! ğŸ‰
