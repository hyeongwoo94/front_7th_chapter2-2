# 단계 7: React 동작 원리 명세서

## 📋 개요

단계 7은 **React의 확장 Hook과 HOC(Higher-Order Component) 패턴**을 설명합니다. React가 어떻게 메모이제이션을 구현하고, 성능을 최적화하며, 컴포넌트를 재사용하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. 메모이제이션 (Memoization)

**원리**: 메모이제이션은 계산 결과를 저장하여 동일한 입력에 대해 재계산을 방지하는 기법입니다. React는 이를 통해 불필요한 재계산과 재렌더링을 방지합니다.

**목적**:

- 불필요한 재계산 방지
- 성능 최적화
- 참조 안정성 유지

**사용 사례**:

- **useMemo**: 값 메모이제이션
- **useCallback**: 함수 메모이제이션
- **memo**: 컴포넌트 메모이제이션

**핵심 개념**:

- 이전 계산 결과를 저장
- 의존성이 변경되지 않으면 저장된 값 반환
- 의존성이 변경되면 재계산

---

### 2. useRef - 참조 객체 훅

**원리**: `useRef`는 리렌더링 없이 값을 유지하는 훅입니다. `.current` 속성으로 값에 접근하며, 값 변경 시 리렌더링을 트리거하지 않습니다.

**구현 원리**:

```typescript
export const useRef = <T>(initialValue: T): { current: T } => {
  const [ref] = useState(() => ({ current: initialValue }));
  return ref;
};
```

**특징**:

- 함수형 초기값을 사용하여 ref 객체를 한 번만 생성
- ref 객체는 재렌더링되어도 유지됨
- `.current` 변경 시 리렌더링 안 함

**사용 사례**:

- DOM 참조 저장
- 이전 값 저장
- 타이머 ID 저장
- 메모이제이션 구현의 기반

**핵심 개념**:

- ref는 재렌더링과 독립적
- 함수형 초기값으로 객체를 한 번만 생성
- useState를 활용한 구현

---

### 3. useMemo - 값 메모이제이션

**원리**: `useMemo`는 계산 결과를 메모이제이션합니다. 의존성 배열을 비교하여 변경되지 않았으면 이전 결과를 반환합니다.

**동작 흐름**:

```
첫 렌더링:
  useMemo(() => compute(a, b), [a, b])
    → ref.current = null
    → compute(a, b) 실행
    → ref.current = { value: result, deps: [a, b] }
    → result 반환

재렌더링 (의존성 변경 안 됨):
  useMemo(() => compute(a, b), [a, b])
    → shallowEquals([a, b], [a, b]) = true
    → compute() 실행 안 함
    → ref.current.value 반환

재렌더링 (의존성 변경됨):
  useMemo(() => compute(a, c), [a, c])
    → shallowEquals([a, b], [a, c]) = false
    → compute(a, c) 실행
    → ref.current = { value: newResult, deps: [a, c] }
    → newResult 반환
```

**핵심 개념**:

- useRef로 이전 의존성과 계산 결과 저장
- 의존성 비교 (`shallowEquals` 기본, 커스텀 가능)
- 의존성이 변경되었을 때만 재계산

**비교 함수**:

- **shallowEquals**: 1단계 깊이만 비교 (기본)
- **deepEquals**: 모든 중첩 구조 비교
- **커스텀 equals**: 사용자 정의 비교 함수

---

### 4. useCallback - 함수 메모이제이션

**원리**: `useCallback`은 함수를 메모이제이션합니다. `useMemo`를 활용하여 구현됩니다.

**구현 원리**:

```typescript
export const useCallback = <T>(callback: T, deps: DependencyList): T => {
  return useMemo(() => callback, deps);
};
```

**특징**:

- 함수 참조 안정성 유지
- 의존성이 변경되지 않으면 같은 함수 참조 반환
- 자식 컴포넌트에 props로 전달 시 불필요한 재렌더링 방지

**사용 사례**:

- 자식 컴포넌트에 콜백 전달
- useEffect 의존성 배열에 함수 포함
- 메모이제이션된 컴포넌트의 props

**핵심 개념**:

- useMemo로 함수를 메모이제이션
- 간단한 구현 (useMemo 활용)
- 참조 안정성이 중요

---

### 5. useAutoCallback - 자동 업데이트 콜백

**원리**: `useAutoCallback`은 최신 상태를 참조하면서 참조 안정적인 콜백을 생성합니다. ref로 최신 함수를 저장하고, useCallback으로 안정적인 래퍼를 생성합니다.

**구현 원리**:

```typescript
export const useAutoCallback = <T>(fn: T): T => {
  const ref = useRef(fn);

  // 항상 최신 함수로 업데이트
  ref.current = fn;

  return useCallback((...args) => {
    return ref.current(...args);
  }, []) as T;
};
```

**특징**:

- ref로 최신 함수 저장
- useCallback으로 안정적인 래퍼 생성
- 함수가 변경되어도 자동으로 최신 함수 호출

**사용 사례**:

- 자식 컴포넌트에 콜백 전달 (최신 상태 참조 필요)
- 이벤트 핸들러 (항상 최신 상태 사용)
- 메모이제이션된 컴포넌트의 props

**핵심 개념**:

- ref로 최신 함수 참조 유지
- useCallback으로 참조 안정성 유지
- 두 가지를 결합한 패턴

---

### 6. memo - 컴포넌트 메모이제이션

**원리**: `memo`는 컴포넌트를 메모이제이션합니다. props를 비교하여 변경되지 않았으면 이전 렌더링 결과를 재사용합니다.

**동작 흐름**:

```
첫 렌더링:
  <Memoized count={1} />
    → ref.current = null
    → Component({ count: 1 }) 실행
    → ref.current = { props: { count: 1 }, result: vnode }
    → vnode 반환

재렌더링 (props 변경 안 됨):
  <Memoized count={1} />
    → shallowEquals({ count: 1 }, { count: 1 }) = true
    → Component() 실행 안 함
    → ref.current.result 반환

재렌더링 (props 변경됨):
  <Memoized count={2} />
    → shallowEquals({ count: 1 }, { count: 2 }) = false
    → Component({ count: 2 }) 실행
    → ref.current = { props: { count: 2 }, result: newVnode }
    → newVnode 반환
```

**핵심 개념**:

- useRef로 이전 props와 렌더링 결과 저장
- props 비교 (`shallowEquals` 기본, 커스텀 가능)
- props가 변경되었을 때만 컴포넌트 재실행

**HOC 패턴**:

- 컴포넌트를 받아서 새로운 컴포넌트 반환
- 기존 컴포넌트를 래핑하여 기능 추가
- 재사용성과 성능 최적화

---

### 7. deepMemo - 깊은 비교 메모이제이션

**원리**: `deepMemo`는 props를 깊게 비교하여 컴포넌트를 메모이제이션합니다. `memo`에 `deepEquals`를 전달하여 구현됩니다.

**구현 원리**:

```typescript
export function deepMemo<P>(Component: FunctionComponent<P>) {
  return memo(Component, deepEquals);
}
```

**특징**:

- props를 깊게 비교
- 중첩 객체의 변경도 감지
- 얕은 비교로는 감지되지 않는 변경도 처리

**사용 사례**:

- 복잡한 객체를 props로 받는 컴포넌트
- 중첩 구조가 깊은 props
- 얕은 비교로는 부족한 경우

**핵심 개념**:

- memo에 deepEquals 전달
- 깊은 비교로 props 변경 감지
- 비용이 크므로 필요한 경우에만 사용

---

## 🔄 React 전체 시스템에서의 위치

단계 7은 React의 **성능 최적화 계층**을 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리]
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation]
         ↓
[단계 6: Hook 시스템] (기반)
         ↓
[단계 7: 확장 Hook & HOC] ← 현재 단계
```

**역할**:

- 성능 최적화를 위한 메모이제이션
- 컴포넌트 재사용성 향상
- 불필요한 재계산 및 재렌더링 방지
- React의 고급 기능 제공

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **메모이제이션**: React는 내부적으로 메모이제이션을 사용하여 최적화
2. **useRef**: React는 Fiber 노드에 ref를 저장
3. **useMemo/useCallback**: React는 의존성 비교를 통해 메모이제이션
4. **memo**: React.memo는 props 비교를 통해 컴포넌트 메모이제이션

---

## 📚 관련 개념

- **Memoization**: 메모이제이션
- **useRef**: 참조 객체 훅
- **useMemo**: 값 메모이제이션 훅
- **useCallback**: 함수 메모이제이션 훅
- **HOC**: 고차 컴포넌트
- **memo**: 컴포넌트 메모이제이션
- **Shallow Comparison**: 얕은 비교
- **Deep Comparison**: 깊은 비교

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. 메모이제이션이 어떻게 동작하는지
2. useRef가 어떻게 값을 유지하는지
3. useMemo와 useCallback의 차이점
4. HOC 패턴이 어떻게 동작하는지
5. 언제 얕은 비교와 깊은 비교를 사용해야 하는지

---

## ⚠️ 중요한 주의사항

1. **의존성 배열**: useMemo/useCallback에서 의존성 배열 정확히 명시
2. **비교 함수 선택**: shallowEquals vs deepEquals 적절히 선택
3. **과도한 메모이제이션**: 모든 것을 메모이제이션하지 말 것
4. **useRef 초기화**: 함수형 초기값 사용 필수

---

## 💡 성능 최적화 관점

메모이제이션을 통해 얻는 이점:

1. **재계산 방지**: 동일한 입력에 대해 재계산 안 함
2. **재렌더링 방지**: props가 같으면 컴포넌트 재실행 안 함
3. **참조 안정성**: 함수나 객체 참조 유지
4. **성능 향상**: 전체적인 렌더링 비용 감소

**주의사항**:

- 메모이제이션 자체도 비용이 있음
- 모든 것을 메모이제이션하면 오히려 성능 저하
- 실제로 성능 문제가 있을 때만 사용

---

이 명세서는 React의 확장 Hook과 HOC 패턴을 설명하며, 성능 최적화와 컴포넌트 재사용을 위한 고급 기능을 이해하는 기반이 됩니다.
