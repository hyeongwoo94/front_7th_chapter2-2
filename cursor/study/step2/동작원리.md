# 단계 2: React 동작 원리 명세서

## 📋 개요

단계 2는 **React Hooks의 내부 상태 관리 메커니즘**을 설명합니다. React가 어떻게 함수형 컴포넌트의 상태를 저장하고 관리하는지, 그리고 훅이 어떻게 동작하는지의 핵심 원리를 다룹니다.

---

## 🎯 설명하는 React 동작 원리

### 1. Hooks 상태 저장 메커니즘

**원리**: React는 함수형 컴포넌트의 상태를 전역 컨텍스트에 저장합니다. 클래스 컴포넌트처럼 인스턴스 변수로 저장하지 않고, 외부 저장소에 경로 기반으로 저장합니다.

**왜 필요한가?**
- 함수형 컴포넌트는 매번 새로 호출되므로, 상태를 외부에 저장해야 함
- 각 컴포넌트의 상태를 격리하여 독립적으로 관리
- 재렌더링 시에도 이전 상태를 유지

**저장 구조**:
```typescript
context.hooks.state = Map<
  "경로",           // 컴포넌트 고유 경로
  [                 // 훅 상태 배열
    state1,         // 첫 번째 useState
    state2,         // 두 번째 useState
    effectHook,     // useEffect
    ...
  ]
>
```

**핵심 개념**:
- 전역 컨텍스트에 상태 저장
- 경로(path) 기반으로 상태 격리
- 배열 인덱스(커서)로 훅 순서 추적

---

### 2. 경로 기반 상태 격리 (Path-based State Isolation)

**원리**: 각 컴포넌트는 고유한 경로를 가지며, 경로별로 훅 상태가 완전히 분리됩니다.

**경로 형식**:
- 루트: `"0"`
- 자식: `부모경로.c인덱스` (key 없음) 또는 `부모경로.i키` (key 있음)
- 예: `"0.c0"`, `"0.c0.i1"`, `"0.c0.i1.c2"`

**핵심 개념**:
- 같은 컴포넌트라도 위치가 다르면 다른 경로를 가짐
- 경로가 다르면 완전히 별개의 상태
- 이로 인해 같은 컴포넌트를 여러 번 사용해도 각각 독립적인 상태 유지

**예시**:
```typescript
// 컴포넌트 A (경로: "0.c0")
const [countA, setCountA] = useState(0);

// 컴포넌트 B (경로: "0.c1")
const [countB, setCountB] = useState(0);

// 같은 useState이지만 다른 경로이므로 다른 상태!
```

---

### 3. 훅 호출 순서 추적 (Hook Call Order Tracking)

**원리**: React는 커서(cursor)를 사용하여 훅 호출 순서를 추적합니다. 각 훅의 상태는 배열에 저장되며, 커서로 접근합니다.

**동작 원리**:
```
컴포넌트 렌더링 시작
  → enterComponent("0.c0")
  → cursor.set("0.c0", 0)  // 커서 0으로 초기화

첫 번째 훅 호출
  → useState(0)
  → cursor=0 사용 → state[0]에 저장
  → incrementCursor() → cursor=1

두 번째 훅 호출
  → useState("hello")
  → cursor=1 사용 → state[1]에 저장
  → incrementCursor() → cursor=2
```

**핵심 개념**:
- 훅은 항상 같은 순서로 호출되어야 함
- 커서로 호출 순서 추적
- 조건문/반복문 안에서 훅 호출 금지 (순서 보장 불가)

**중요성**:
- 훅 호출 순서가 달라지면 잘못된 상태를 참조하게 됨
- React의 "Rules of Hooks" 규칙의 근본 원인

---

### 4. 컴포넌트 스택 관리 (Component Stack Management)

**원리**: React는 컴포넌트 실행 스택을 관리하여 현재 어떤 컴포넌트가 실행 중인지 추적합니다.

**동작 예시**:
```
1. 루트 컴포넌트 진입
   componentStack = ["0"]
   currentPath = "0"

2. 자식 컴포넌트 A 진입
   componentStack = ["0", "0.c0"]
   currentPath = "0.c0"

3. 자식 컴포넌트 B 진입
   componentStack = ["0", "0.c0", "0.c0.i1"]
   currentPath = "0.c0.i1"

4. 컴포넌트 B 종료
   componentStack = ["0", "0.c0"]
   currentPath = "0.c0"
```

**핵심 개념**:
- `currentPath`는 항상 `componentStack`의 마지막 요소
- 스택이 비어있으면 훅을 호출할 수 없음
- 컴포넌트 외부에서 훅 호출 시 에러 발생

---

### 5. 렌더링 사이클 관리 (Render Cycle Management)

**원리**: 렌더링 간 어떤 상태를 유지하고 무엇을 초기화할지 결정해야 합니다.

**상태 보존 vs 초기화**:

| 항목 | 초기화 여부 | 이유 |
|------|-----------|------|
| `visited` | ✅ 매 렌더링마다 | 방문 기록은 렌더링마다 새로 시작 |
| `componentStack` | ✅ 매 렌더링마다 | 컴포넌트 실행 스택은 렌더링마다 새로 시작 |
| `state` | ❌ 유지 | 훅 상태는 렌더링 간 유지해야 함 |
| `cursor` | ❌ 유지 | 커서 위치도 유지 (훅 순서 추적) |

**핵심 개념**:
- 훅 상태(`state`)와 커서(`cursor`)는 렌더링 간 유지
- 컴포넌트 스택과 방문 기록은 매 렌더링마다 초기화
- 이를 통해 재렌더링 시에도 이전 상태를 올바르게 복원

---

## 🔄 React 전체 시스템에서의 위치

단계 2는 React의 **상태 관리 인프라**를 구성합니다:

```
[단계 1: Virtual DOM & JSX 변환]
         ↓
[단계 2: 컨텍스트 & 상태 관리] ← 현재 단계
         ↓
[단계 3: DOM 인터페이스]
         ↓
[단계 4: 렌더 스케줄링]
         ↓
[단계 5: Reconciliation]
         ↓
[단계 6: Hook 시스템] (단계 2 기반)
```

**역할**:
- Hooks가 동작하는 기반 인프라 구축
- 컴포넌트 상태 격리 시스템 제공
- 이후 Hook 구현(단계 6)의 기반

---

## 💡 실제 React에서의 구현

실제 React 코드에서도 동일한 원리가 적용됩니다:

1. **전역 컨텍스트**: React는 내부적으로 Fiber 노드에 훅 상태를 저장
2. **경로 기반 격리**: 각 Fiber 노드는 고유한 식별자를 가짐
3. **커서 추적**: React는 내부적으로 훅 인덱스를 추적
4. **스택 관리**: React는 컴포넌트 스택을 관리하여 에러 추적

---

## 📚 관련 개념

- **Hooks Context**: 훅 상태를 관리하는 컨텍스트
- **Component Path**: 컴포넌트 고유 경로
- **Hook Cursor**: 훅 호출 순서를 추적하는 인덱스
- **Component Stack**: 현재 실행 중인 컴포넌트 스택
- **State Isolation**: 상태 격리
- **Render Cycle**: 렌더링 사이클

---

## 🎓 학습 목표

이 단계를 완료하면 다음을 이해할 수 있습니다:

1. React가 어떻게 함수형 컴포넌트의 상태를 저장하는지
2. 각 컴포넌트의 상태가 어떻게 격리되는지
3. 훅 호출 순서가 왜 중요한지
4. 렌더링 간 상태가 어떻게 유지되는지

---

## ⚠️ 중요한 규칙

1. **훅은 컴포넌트 내부에서만 호출**: `currentPath`가 없으면 에러
2. **훅 호출 순서 유지**: 조건문/반복문 안에서 훅 호출 금지
3. **경로 기반 격리**: 경로가 다르면 완전히 별개의 상태

---

이 명세서는 React Hooks가 동작하는 핵심 원리를 설명하며, 함수형 컴포넌트의 상태 관리 메커니즘을 이해하는 기반이 됩니다.

