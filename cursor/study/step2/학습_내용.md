# 단계 2: 컨텍스트와 루트 초기화 - 학습 내용

이 문서는 단계 2에서 학습해야 할 핵심 개념과 구현 내용을 설명합니다.

## 📚 핵심 개념

### 1. 컨텍스트 구조

Mini-React는 전역 컨텍스트를 통해 렌더링 상태와 훅 상태를 관리합니다.

```typescript
Context {
  root: {
    container: HTMLElement | null;  // DOM 컨테이너
    node: VNode | null;              // 루트 VNode
    instance: Instance | null;       // 루트 인스턴스
  };
  hooks: {
    state: Map<string, any[]>;       // 경로별 훅 상태 배열
    cursor: Map<string, number>;     // 경로별 훅 커서
    visited: Set<string>;            // 방문한 컴포넌트 경로
    componentStack: string[];        // 현재 실행 중인 컴포넌트 스택
  };
  effects: {
    queue: Array<{ path, cursor }>;  // 이펙트 실행 큐
  };
}
```

---

### 2. 경로 기반 상태 격리

각 컴포넌트는 고유한 경로(path)를 가지며, 경로별로 훅 상태가 완전히 분리됩니다.

**경로 형식**:
- 루트: `"0"`
- 자식: `부모경로.c인덱스` (key 없음) 또는 `부모경로.i키` (key 있음)
- 예: `"0.c0"`, `"0.c0.i1"`, `"0.c0.i1.c2"`

**예시**:
```typescript
// 컴포넌트 A (경로: "0.c0")
const [countA, setCountA] = useState(0);  // cursor: 0

// 컴포넌트 B (경로: "0.c1")
const [countB, setCountB] = useState(0);  // cursor: 0 (독립적인 상태!)

// 같은 컴포넌트라도 위치가 다르면 다른 상태
```

**상태 저장 구조**:
```typescript
context.hooks.state = Map {
  "0.c0" => [countA 상태, ...],
  "0.c1" => [countB 상태, ...],
  "0.c0.i1" => [다른 상태, ...],
}
```

---

### 3. 컴포넌트 스택

컴포넌트 실행 시 스택에 경로를 추가하고, 종료 시 제거합니다.

**동작 예시**:
```typescript
// 컴포넌트 실행 순서
1. 루트 컴포넌트 진입
   componentStack = ["0"]
   currentPath = "0"

2. 자식 컴포넌트 A 진입
   componentStack = ["0", "0.c0"]
   currentPath = "0.c0"

3. 자식 컴포넌트 B 진입
   componentStack = ["0", "0.c0", "0.c0.i1"]
   currentPath = "0.c0.i1"

4. 컴포넌트 B 종료
   componentStack = ["0", "0.c0"]
   currentPath = "0.c0"

5. 컴포넌트 A 종료
   componentStack = ["0"]
   currentPath = "0"
```

**핵심**:
- `currentPath`는 항상 `componentStack`의 마지막 요소
- 스택이 비어있으면 훅을 호출할 수 없음

---

### 4. 훅 커서

각 컴포넌트마다 독립적인 커서를 가지며, 훅 호출 순서를 추적합니다.

**동작 원리**:
```typescript
// 컴포넌트 렌더링 시작
enterComponent("0.c0")
  → cursor.set("0.c0", 0)  // 커서 0으로 초기화

// 첫 번째 훅 호출
useState(0)
  → cursor=0 사용
  → incrementCursor("0.c0")
  → cursor=1

// 두 번째 훅 호출
useState("hello")
  → cursor=1 사용
  → incrementCursor("0.c0")
  → cursor=2

// 세 번째 훅 호출
useEffect(() => {})
  → cursor=2 사용
  → incrementCursor("0.c0")
  → cursor=3

// 컴포넌트 종료
exitComponent()
```

**중요**: 훅은 항상 같은 순서로 호출되어야 합니다!

---

### 5. 상태 보존 vs 초기화

렌더링 간 어떤 상태를 유지하고 무엇을 초기화할지 결정해야 합니다.

| 항목 | 초기화 여부 | 이유 |
|------|-----------|------|
| `visited` | ✅ 매 렌더링마다 | 방문 기록은 렌더링마다 새로 시작 |
| `componentStack` | ✅ 매 렌더링마다 | 컴포넌트 실행 스택은 렌더링마다 새로 시작 |
| `state` | ❌ 유지 | 훅 상태는 렌더링 간 유지해야 함 |
| `cursor` | ❌ 유지 | 커서 위치도 유지 (훅 순서 추적) |

**예시**:
```typescript
// 첫 번째 렌더링
useState(0) → state 저장, cursor=0

// 두 번째 렌더링 (재렌더링)
useState(0) → 이전 state 사용, cursor=0 (동일한 위치!)
```

---

## 🔧 구현 함수 상세

### 1. `root.reset()`

**목적**: 루트 컨텍스트 초기화

**구현**:
```typescript
reset({ container, node }) {
  this.container = container;
  this.node = node;
  this.instance = null;  // 항상 null로 초기화
}
```

**요점**:
- container와 node를 전달받은 값으로 설정
- instance는 항상 null (새로 렌더링되므로)

---

### 2. `hooks.clear()`

**목적**: 훅 컨텍스트 초기화 (일부만)

**구현**:
```typescript
clear() {
  this.visited.clear();        // 방문 기록 초기화
  this.componentStack = [];    // 스택 초기화
  // state와 cursor는 유지! (훅 상태 보존)
}
```

**중요**: state와 cursor는 유지해야 합니다!

---

### 3. `hooks.currentPath`

**목적**: 현재 컴포넌트 경로 가져오기

**구현**:
```typescript
get currentPath() {
  const path = this.componentStack[this.componentStack.length - 1];
  if (!path) {
    throw new Error("훅은 컴포넌트 내부에서만 호출되어야 합니다.");
  }
  return path;
}
```

**요점**:
- componentStack의 마지막 요소 반환
- 스택이 비어있으면 에러 (훅 호출 위치 검증)

---

### 4. `hooks.currentCursor`

**목적**: 현재 훅 커서 가져오기

**구현**:
```typescript
get currentCursor() {
  const path = this.currentPath;
  return this.cursor.get(path) ?? 0;
}
```

**요점**:
- 현재 경로의 커서 조회
- 없으면 0 (첫 훅 호출)

---

### 5. `hooks.currentHooks`

**목적**: 현재 컴포넌트의 훅 상태 배열 가져오기

**구현**:
```typescript
get currentHooks() {
  const path = this.currentPath;
  return this.state.get(path) ?? [];
}
```

**요점**:
- 현재 경로의 훅 배열 조회
- 없으면 빈 배열 (첫 렌더링)

---

### 6. `enterComponent(path)`

**목적**: 컴포넌트 진입 시 호출

**구현**:
```typescript
export const enterComponent = (path: string): void => {
  context.hooks.componentStack.push(path);    // 스택에 추가
  context.hooks.cursor.set(path, 0);          // 커서 0으로 초기화
  context.hooks.visited.add(path);            // 방문 표시
};
```

**핵심**:
- 스택에 경로 추가
- 커서를 0으로 초기화 (새 컴포넌트)
- visited에 추가

---

### 7. `exitComponent()`

**목적**: 컴포넌트 종료 시 호출

**구현**:
```typescript
export const exitComponent = (): void => {
  context.hooks.componentStack.pop();
};
```

**요점**:
- 스택에서 마지막 요소 제거
- try-finally로 반드시 호출 보장

---

### 8. `incrementCursor(path)`

**목적**: 훅 커서 증가

**구현**:
```typescript
export const incrementCursor = (path: string): void => {
  const current = context.hooks.cursor.get(path) ?? 0;
  context.hooks.cursor.set(path, current + 1);
};
```

**요점**:
- 해당 경로의 커서를 1 증가
- 각 훅 호출마다 호출됨

---

### 9. `setup(rootNode, container)`

**목적**: 루트 렌더링 시작

**구현**:
```typescript
export const setup = (rootNode: VNode | null, container: HTMLElement): void => {
  // 1. 컨테이너 유효성 검사
  if (!container) {
    throw new Error("컨테이너가 제공되지 않았습니다.");
  }

  // 2. 이전 렌더링 내용 정리
  if (context.root.instance) {
    removeInstance(container, context.root.instance);
  }

  // 3. 루트 컨텍스트와 훅 컨텍스트 리셋
  if (rootNode !== null) {
    context.root.reset({ container, node: rootNode });
  }
  context.hooks.clear();

  // 4. 첫 렌더링 실행
  render();
};
```

**처리 순서**:
1. 컨테이너 검사
2. 이전 인스턴스 제거
3. 컨텍스트 리셋
4. 렌더링 실행

---

## 💡 핵심 원칙

### 1. 경로 격리

- 경로가 다르면 완전히 별개의 상태
- 같은 컴포넌트라도 위치가 다르면 다른 상태

### 2. 훅 호출 순서

- 훅은 항상 같은 순서로 호출되어야 함
- 커서로 호출 순서 추적

### 3. 상태 보존

- state와 cursor는 렌더링 간 유지
- visited와 componentStack은 렌더링마다 초기화

### 4. 스택 관리

- enter/exit은 쌍으로 호출
- try-finally로 보장

---

## 🎯 실습 예시

### 예시 1: 경로 기반 상태 격리

```typescript
// 컴포넌트 A
function ComponentA() {
  const [count, setCount] = useState(0);  // 경로: "0.c0", cursor: 0
  return <div>{count}</div>;
}

// 컴포넌트 B
function ComponentB() {
  const [count, setCount] = useState(0);  // 경로: "0.c1", cursor: 0
  return <div>{count}</div>;
}

// 같은 useState이지만 다른 경로이므로 다른 상태!
```

### 예시 2: 커서 동작

```typescript
function MyComponent() {
  const [a, setA] = useState(1);      // cursor: 0
  const [b, setB] = useState(2);      // cursor: 1
  const [c, setC] = useState(3);      // cursor: 2
  
  // 첫 렌더링: cursor=0,1,2 사용
  // 두 번째 렌더링: 동일한 cursor=0,1,2 사용 (같은 순서!)
}
```

---

## ⚠️ 주의사항

1. **컨텍스트 초기화**: visited와 componentStack만 초기화, state와 cursor는 유지
2. **경로 격리**: 경로가 다르면 완전히 별개의 상태
3. **스택 관리**: enter/exit이 쌍으로 호출되도록 보장
4. **에러 처리**: currentPath가 null이면 에러 발생

---

## 🔄 다음 단계

이제 컨텍스트와 루트 초기화가 완료되었습니다. 다음 단계에서는 DOM 인터페이스를 구현합니다.

**다음 단계**: [단계 3 - DOM 인터페이스](../docs/step-03-dom-interface.md)

