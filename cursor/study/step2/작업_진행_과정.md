# 단계 2: 작업 진행 과정

Teacher가 단계 2를 구현한 과정을 간결하게 정리합니다.

## 📋 작업 순서

1. **타입 정의 확인** → 기존 타입 구조 파악
2. **컨텍스트 관리 함수 구현** → context.ts
3. **컴포넌트 관리 함수 구현** → enterComponent, exitComponent, incrementCursor
4. **루트 초기화 구현** → setup.ts

---

## 🔧 구현 내용

### 1. `root.reset()` (`core/context.ts`)

**구현**:

```typescript
reset({ container, node }) {
  this.container = container;
  this.node = node;
  this.instance = null;
}
```

**요점**:

- container와 node를 전달받은 값으로 초기화
- instance는 항상 null로 초기화 (새로 렌더링되므로)

---

### 2. `hooks.clear()` (`core/context.ts`)

**구현**:

```typescript
clear() {
  this.visited.clear();
  this.componentStack = [];
  // state와 cursor는 유지 (훅 상태 보존)
}
```

**핵심 포인트**:

- **visited와 componentStack 초기화**: 매 렌더링마다 초기화
- **state와 cursor 유지**: 훅 상태는 보존해야 함
- 렌더링 간 훅 상태를 유지하기 위해 state와 cursor는 유지

---

### 3. `hooks.currentPath` (`core/context.ts`)

**구현**:

```typescript
get currentPath() {
  const path = this.componentStack[this.componentStack.length - 1];
  if (!path) {
    throw new Error("훅은 컴포넌트 내부에서만 호출되어야 합니다.");
  }
  return path;
}
```

**핵심 포인트**:

- **componentStack의 마지막 요소**: 현재 실행 중인 컴포넌트 경로
- **에러 처리**: 스택이 비어있으면 훅 호출 위치 에러 발생
- 훅은 컴포넌트 내부에서만 호출되어야 함

---

### 4. `hooks.currentCursor` (`core/context.ts`)

**구현**:

```typescript
get currentCursor() {
  const path = this.currentPath;
  return this.cursor.get(path) ?? 0;
}
```

**요점**:

- 현재 경로의 커서 조회
- 없으면 0 (첫 훅 호출)

---

### 5. `hooks.currentHooks` (`core/context.ts`)

**구현**:

```typescript
get currentHooks() {
  const path = this.currentPath;
  return this.state.get(path) ?? [];
}
```

**요점**:

- 현재 경로의 훅 상태 배열 조회
- 없으면 빈 배열 (첫 렌더링)

---

### 6. `enterComponent` (`core/context.ts`)

**구현**:

```typescript
export const enterComponent = (path: string): void => {
  context.hooks.componentStack.push(path);
  context.hooks.cursor.set(path, 0);
  context.hooks.visited.add(path);
};
```

**핵심 포인트**:

- **componentStack에 경로 추가**: 컴포넌트 실행 시작
- **커서 0으로 초기화**: 새 컴포넌트이므로 커서 리셋
- **visited에 추가**: 방문한 경로로 표시

---

### 7. `exitComponent` (`core/context.ts`)

**구현**:

```typescript
export const exitComponent = (): void => {
  context.hooks.componentStack.pop();
};
```

**요점**:

- 스택에서 마지막 요소 제거
- try-finally로 반드시 호출되도록 보장

---

### 8. `incrementCursor` (`core/context.ts`)

**구현**:

```typescript
export const incrementCursor = (path: string): void => {
  const current = context.hooks.cursor.get(path) ?? 0;
  context.hooks.cursor.set(path, current + 1);
};
```

**요점**:

- 해당 경로의 커서를 1 증가
- 각 훅 호출마다 호출됨

---

### 9. `setup` (`core/setup.ts`)

**처리 순서**:

1. 컨테이너 유효성 검사 (없으면 에러)
2. 이전 렌더링 내용 정리 (removeInstance)
3. 루트 컨텍스트와 훅 컨텍스트 리셋
4. 첫 렌더링 실행 (render)

**구현**:

```typescript
export const setup = (rootNode: VNode | null, container: HTMLElement): void => {
  // 1. 컨테이너 유효성 검사
  if (!container) {
    throw new Error("컨테이너가 제공되지 않았습니다.");
  }

  // 2. 이전 렌더링 내용 정리
  if (context.root.instance) {
    removeInstance(container, context.root.instance);
  }

  // 3. 루트 컨텍스트와 훅 컨텍스트 리셋
  if (rootNode !== null) {
    context.root.reset({ container, node: rootNode });
  }
  context.hooks.clear();

  // 4. 첫 렌더링 실행
  render();
};
```

**핵심**:

- visited와 componentStack은 매 렌더링마다 초기화
- state와 cursor는 유지 (훅 상태 보존)
- rootNode가 null이면 reset 호출 안 함

---

## ✅ 테스트 확인

이 단계만으로는 독립적인 테스트가 없음. 다음 단계들과 함께 테스트 통과.

**확인 사항**:

- 컨텍스트가 올바르게 생성되는지
- componentStack이 올바르게 관리되는지
- setup이 컨테이너를 올바르게 초기화하는지

---

## 🎯 핵심 원칙

### 1. 경로 기반 상태 격리

- 각 컴포넌트는 고유한 경로(`"0"`, `"0.c0"`, `"0.c0.i1"` 등)
- 경로별로 훅 상태가 완전히 분리됨
- 같은 컴포넌트라도 위치가 다르면 다른 상태를 가짐

### 2. 훅 커서 동작

- 컴포넌트마다 독립적인 커서
- 훅 호출 순서를 추적하여 상태와 매칭
- 예: 첫 번째 useState → cursor=0, 두 번째 useState → cursor=1

### 3. 컴포넌트 스택

- `enterComponent` → 스택에 추가
- `exitComponent` → 스택에서 제거
- try-finally로 반드시 쌍으로 호출

### 4. 상태 보존 vs 초기화

| 항목 | 초기화 여부 | 이유 |
|------|-----------|------|
| visited | 매 렌더링마다 | 방문 기록은 렌더링마다 새로 시작 |
| componentStack | 매 렌더링마다 | 컴포넌트 실행 스택은 렌더링마다 새로 시작 |
| state | 유지 | 훅 상태는 렌더링 간 유지해야 함 |
| cursor | 유지 | 커서 위치도 유지 (훅 순서 추적) |

---

## 📚 학습 요약

### 컨텍스트 구조

```
Context
├── root: { container, node, instance }
├── hooks:
│   ├── state: Map<경로, 훅상태배열>
│   ├── cursor: Map<경로, 커서번호>
│   ├── visited: Set<경로>
│   └── componentStack: string[]
└── effects: { queue }
```

### 경로 생성 규칙

- 루트: `"0"`
- 자식: `부모경로.c인덱스` (key 없음) 또는 `부모경로.i키` (key 있음)
- 예: `"0.c0"`, `"0.i1"`, `"0.c0.i2"`

### 스택 관리

```
컴포넌트 진입:
  enterComponent("0.c0")
  → componentStack = ["0", "0.c0"]
  → currentPath = "0.c0"

컴포넌트 종료:
  exitComponent()
  → componentStack = ["0"]
  → currentPath = "0"
```

### 훅 커서 동작 예시

```
컴포넌트 렌더링:
  1. enterComponent("0.c0") → cursor.set("0.c0", 0)
  2. useState() → cursor=0 사용 → incrementCursor() → cursor=1
  3. useState() → cursor=1 사용 → incrementCursor() → cursor=2
  4. useEffect() → cursor=2 사용 → incrementCursor() → cursor=3
  5. exitComponent()
```

---

## 💡 자주 하는 실수

1. **visited 초기화**: 매 렌더링마다 초기화해야 함 (state, cursor는 유지)
2. **스택 불일치**: enter/exit이 쌍으로 호출되지 않음
3. **커서 초기화**: enterComponent에서 반드시 0으로 초기화
4. **경로 격리**: 경로가 다르면 완전히 별개의 상태로 관리
5. **에러 처리 누락**: currentPath가 null일 때 에러 발생 안 함

---

다음 단계: **단계 3 - DOM 인터페이스**

